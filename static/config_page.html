<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Doggo Config</title>
    <style>
        :root {
            --bg: #0f1220;
            --panel: #181c2f;
            --accent: #4da3ff;
            --text: #e6e8f0;
            --muted: #9aa0b3;
            --selected: #263a5f;
            --danger: #ff5d5d;
            --ok: #4cff91;
            --card: #0f1220;
            --border: rgba(255, 255, 255, .14);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
            background: var(--bg);
            color: var(--text);
        }

        .wrap {
            display: grid;
            grid-template-columns: 1fr 380px;
            grid-template-rows: 1fr 260px;
            height: 100vh;
            gap: 12px;
            padding: 12px;
        }

        .main {
            background: var(--panel);
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .sidebar {
            background: var(--panel);
            border-radius: 16px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: auto;
            min-width: 0;
        }

        .bar {
            grid-column: 1 / span 2;
            background: var(--panel);
            border-radius: 16px;
            padding: 12px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            overflow: auto;
        }

        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 12px;
            height: 100%;
            min-width: 0;
        }

        .title {
            font-weight: 900;
            font-size: 18px;
            margin: 0 0 4px 0;
        }

        .muted {
            color: var(--muted);
            font-size: 13px;
        }

        .divider {
            height: 1px;
            background: rgba(255, 255, 255, .10);
            margin: 8px 0;
        }

        button {
            background: transparent;
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 12px;
            padding: 10px 12px;
            cursor: pointer;
            user-select: none;
        }

        button.primary {
            border-color: var(--accent);
            color: var(--accent);
        }

        button.selected {
            outline: 2px solid var(--accent);
            background: rgba(38, 58, 95, .55);
        }

        button:disabled {
            opacity: .35;
            cursor: not-allowed;
        }

        .danger {
            color: var(--danger);
        }

        .ok {
            color: var(--ok);
        }

        input[type="number"],
        input[type="text"],
        select {
            width: 100%;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: #0f1220;
            color: var(--text);
        }

        textarea {
            width: 100%;
            min-height: 130px;
            resize: vertical;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: #0f1220;
            color: var(--text);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            line-height: 1.35;
        }

        .row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
            min-width: 0;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 0;
        }

        .radioRow {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .radioPill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 12px;
            background: rgba(15, 18, 32, .45);
            cursor: pointer;
            user-select: none;
        }

        .radioPill input {
            transform: translateY(1px);
        }

        /* Main: canvas */
        .mainHeader {
            padding: 12px 14px;
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, .10);
        }

        .mainBody {
            padding: 14px;
            overflow: hidden;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
        }

        .canvasWrap {
            flex: 1;
            min-height: 0;
            border: 1px solid rgba(255, 255, 255, .14);
            border-radius: 14px;
            background: rgba(15, 18, 32, .55);
            overflow: hidden;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .canvasOverlay {
            position: absolute;
            left: 10px;
            top: 10px;
            padding: 8px 10px;
            border-radius: 12px;
            background: rgba(15, 18, 32, .72);
            border: 1px solid rgba(255, 255, 255, .12);
            font-size: 12px;
            color: var(--muted);
            max-width: calc(100% - 20px);
        }

        /* Bottom bar left: servo selector grid */
        .selectorWrap {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            min-width: 0;
        }

        .selectorTopLabels {
            display: grid;
            grid-template-columns: 1fr 1fr 160px 1fr 1fr;
            gap: 10px;
            align-items: center;
            justify-items: center;
            padding: 0 2px;
        }

        .selectorTopLabels .lr {
            font-weight: 800;
            color: var(--muted);
            font-size: 12px;
            letter-spacing: .6px;
            text-transform: uppercase;
        }

        .selectorGridArea {
            display: grid;
            grid-template-columns: 64px 1fr 1fr 160px 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 10px;
            align-items: center;
            min-width: 0;
        }

        .rowLabel {
            font-weight: 900;
            color: var(--muted);
            font-size: 12px;
            letter-spacing: .6px;
            text-transform: uppercase;
            text-align: right;
            padding-right: 4px;
        }

        .servoBtn {
            width: 100%;
            font-weight: 800;
            text-transform: lowercase;
            white-space: nowrap;
        }

        .channelBlock {
            grid-column: 4;
            grid-row: 1 / span 2;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-self: stretch;
            justify-content: center;
            min-width: 0;
        }

        .channelBlock label {
            font-size: 12px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: .6px;
            font-weight: 800;
            text-align: center;
        }

        /* Bottom bar right: angle control */
        .angleWrap {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            min-width: 0;
        }

        .angleRow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .steps {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .angleBox {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, .14);
            border-radius: 14px;
            background: #0f1220;
        }

        .angleBox input {
            width: 110px;
            text-align: center;
            font-size: 18px;
            font-weight: 900;
            padding: 10px 10px;
        }

        .hotkeys {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .tiny {
            font-size: 12px;
            padding: 8px 10px;
            border-radius: 10px;
            min-width: 70px;
        }

        /* Sidebar sections */
        .sidebarSection {
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 14px;
            padding: 12px;
            background: rgba(15, 18, 32, .40);
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 0;
        }

        .sectionTitle {
            font-weight: 900;
            font-size: 14px;
            margin-bottom: 2px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sectionTitle::after {
            content: "▾";
            font-size: 12px;
            opacity: 0.8;
        }

        .sidebarSection.collapsed>.sectionTitle::after {
            content: "▸";
        }

        .sidebarSection.collapsed>:not(.sectionTitle) {
            display: none;
        }

        .grid2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .grid3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .pairsList {
            max-height: 180px;
            overflow: auto;
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 10px;
            padding: 6px;
        }

        .pairRow {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, .08);
        }

        .pairRow:last-child {
            border-bottom: none;
        }
    </style>
</head>

<body>
    <div class="wrap">

        <div class="main">
            <div class="mainHeader">
                <div>
                    <div class="title">Dynamic limits</div>
                    <div class="muted">2D capsule depiction + collision clamp preview (Normal/Test).</div>
                </div>
                <div id="hw-status" class="muted"></div>
            </div>

            <div class="mainBody">
                <div class="row">
                    <div class="radioRow">
                        <span class="muted" style="font-weight:900;">Side</span>
                        <label class="radioPill">
                            <input type="radio" name="side" id="sideLeft" value="left">
                            <span>Left</span>
                        </label>
                        <label class="radioPill">
                            <input type="radio" name="side" id="sideRight" value="right">
                            <span>Right</span>
                        </label>
                    </div>

                    <div class="muted" id="poseInfo">—</div>
                </div>

                <div class="canvasWrap">
                    <canvas id="viz"></canvas>
                    <div class="canvasOverlay" id="vizOverlay">
                        Select a side, then move servos (Normal/Test) to see the capsules update.
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="row" style="align-items:flex-start;">
                <div>
                    <div class="title" style="margin:0;">Doggo Config</div>
                    <div class="muted">Channel mapping + travel limits + collision model + notes/hotkeys.</div>
                </div>
            </div>

            <div class="row">
                <button id="saveBtn" class="primary" disabled>Save</button>
                <button id="resetBtn" disabled>Reset</button>
            </div>

            <div class="sidebarSection">
                <div class="sectionTitle">Travel limits</div>
                <div class="muted">Selected: <span id="selectedLabel">None</span></div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Min angle</label>
                        <input id="minDeg" type="number" min="0" max="270" step="1" disabled />
                    </div>

                    <div class="field">
                        <label class="muted">Max angle</label>
                        <input id="maxDeg" type="number" min="0" max="270" step="1" disabled />
                    </div>
                </div>

                <div class="row">
                    <label class="muted" for="invertChk">Invert</label>
                    <input id="invertChk" type="checkbox" disabled />
                </div>
            </div>

            <div class="sidebarSection">
                <div class="sectionTitle">Collision model</div>

                <div class="muted">Edits save to <span class="mono">config/dynamic_limits.json</span>.</div>

                <div class="divider"></div>

                <div style="font-weight:900;">Global</div>
                <div class="grid2">
                    <div class="field">
                        <label class="muted">Search step (deg)</label>
                        <input id="dl_step" type="number" min="1" max="45" step="1">
                    </div>
                    <div class="field">
                        <label class="muted">Search max iters</label>
                        <input id="dl_iters" type="number" min="1" max="5000" step="1">
                    </div>
                </div>

                <div class="divider"></div>

                <div style="font-weight:900;">Side variables (<span id="dl_side_label">left</span>)</div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Hip dx (mm)</label>
                        <input id="dl_hip_dx" type="number" step="1">
                    </div>
                    <div class="field">
                        <label class="muted">Hip y (mm)</label>
                        <input id="dl_hip_y" type="number" step="1">
                    </div>
                </div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Front thigh len (mm)</label>
                        <input id="dl_ltf" type="number" step="1">
                    </div>
                    <div class="field">
                        <label class="muted">Front shin len (mm)</label>
                        <input id="dl_lsf" type="number" step="1">
                    </div>
                </div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Rear thigh len (mm)</label>
                        <input id="dl_ltr" type="number" step="1">
                    </div>
                    <div class="field">
                        <label class="muted">Rear shin len (mm)</label>
                        <input id="dl_lsr" type="number" step="1">
                    </div>
                </div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Front knee attach backoff (mm)</label>
                        <input id="dl_kab_f" type="number" step="1">
                    </div>
                    <div class="field">
                        <label class="muted">Rear knee attach backoff (mm)</label>
                        <input id="dl_kab_r" type="number" step="1">
                    </div>
                </div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Front thigh radius (mm)</label>
                        <input id="dl_r_ft" type="number" step="1">
                    </div>
                    <div class="field">
                        <label class="muted">Front shin radius (mm)</label>
                        <input id="dl_r_fs" type="number" step="1">
                    </div>
                </div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Rear thigh radius (mm)</label>
                        <input id="dl_r_rt" type="number" step="1">
                    </div>
                    <div class="field">
                        <label class="muted">Rear shin radius (mm)</label>
                        <input id="dl_r_rs" type="number" step="1">
                    </div>
                </div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Front hip offset (deg)</label>
                        <input id="dl_off_fh" type="number" step="1">
                    </div>
                    <div class="field">
                        <label class="muted">Front knee offset (deg)</label>
                        <input id="dl_off_fk" type="number" step="1">
                    </div>
                </div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Rear hip offset (deg)</label>
                        <input id="dl_off_rh" type="number" step="1">
                    </div>
                    <div class="field">
                        <label class="muted">Rear knee offset (deg)</label>
                        <input id="dl_off_rk" type="number" step="1">
                    </div>
                </div>

                <div class="divider"></div>
                <div style="font-weight:900;">Relative angles (sim)</div>
                <div class="grid2">
                    <div class="field">
                        <label class="muted">Hip line vs front thigh</label>
                        <input id="geoHipFront" type="text" value="—" readonly />
                    </div>
                    <div class="field">
                        <label class="muted">Hip line vs rear thigh</label>
                        <input id="geoHipRear" type="text" value="—" readonly />
                    </div>
                </div>
                <div class="grid2">
                    <div class="field">
                        <label class="muted">Front thigh vs shin</label>
                        <input id="geoRelFront" type="text" value="—" readonly />
                    </div>
                    <div class="field">
                        <label class="muted">Rear thigh vs shin</label>
                        <input id="geoRelRear" type="text" value="—" readonly />
                    </div>
                </div>

                <div class="muted" id="dl_status">—</div>
            </div>

            <div class="sidebarSection">
                <div class="sectionTitle">Calibration</div>
                <div class="muted">Simulation-only linear fit. Commands sent to servos are unchanged.</div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Profile</label>
                        <select id="cal_profile_select"></select>
                    </div>
                    <div class="field">
                        <label class="muted">Measurement mode</label>
                        <select id="cal_mode_select">
                            <option value="servo_physical_deg">Servo physical (legacy)</option>
                            <option value="hip_line_relative_deg">Hip line relative</option>
                            <option value="knee_relative_deg">Knee relative</option>
                        </select>
                    </div>
                </div>
                <div class="grid2">
                    <div class="field">
                        <label class="muted">New profile</label>
                        <input id="cal_new_profile" type="text" placeholder="e.g. hip_standard" />
                    </div>
                    <div></div>
                </div>
                <div class="row">
                    <button id="cal_create_profile_btn">Create</button>
                    <button id="cal_delete_profile_btn">Delete</button>
                </div>

                <div class="grid2">
                    <div class="field">
                        <label class="muted">Commanded (deg)</label>
                        <input id="cal_cmd_input" type="number" min="0" max="270" step="0.1" />
                    </div>
                    <div class="field">
                        <label class="muted">Actual (deg)</label>
                        <input id="cal_actual_input" type="number" min="0" max="270" step="0.1" />
                    </div>
                </div>
                <div class="row">
                    <button id="cal_add_pair_btn">Add pair</button>
                </div>

                <div id="cal_fit_summary" class="muted">—</div>
                <div id="cal_pairs_list" class="pairsList"></div>

                <div class="divider"></div>
                <div style="font-weight:900;">Joint profile assignment</div>
                <div id="cal_joint_map" class="field"></div>
            </div>

            <div class="sidebarSection">
                <div class="sectionTitle">Sim Direction Flip</div>
                <div class="muted">Per-joint simulation direction inversion.</div>
                <div id="sim_flip_map" class="field"></div>
            </div>

            <div class="sidebarSection">
                <div class="sectionTitle">Universal settings</div>

                <div>
                    <div style="font-weight:900; margin-bottom:6px;">Hotkeys (programmable)</div>
                    <div class="muted" style="margin-bottom:8px;">Edit values here; buttons are on the bottom-right.
                    </div>
                    <div class="field" style="gap:10px;">
                        <input id="hk0" type="number" min="0" max="270" step="1" />
                        <input id="hk1" type="number" min="0" max="270" step="1" />
                        <input id="hk2" type="number" min="0" max="270" step="1" />
                        <input id="hk3" type="number" min="0" max="270" step="1" />
                        <input id="hk4" type="number" min="0" max="270" step="1" />
                        <input id="hk5" type="number" min="0" max="270" step="1" />
                    </div>
                </div>

                <div class="divider"></div>

                <div>
                    <div style="font-weight:900; margin-bottom:6px;">Notes</div>
                    <textarea id="notesArea"
                        placeholder="Saved to config/channel_notes.json (not part of config_file.json)."></textarea>
                    <div id="notesStatus" class="muted" style="margin-top:6px;">—</div>
                </div>
            </div>

            <div class="sidebarSection">
                <div class="sectionTitle">Stances</div>
                <div class="muted">Select a stance file from <code>stances/</code> and activate it.</div>
                <div class="row">
                    <select id="stanceSelect"></select>
                    <button id="activateStanceBtn" class="primary">Activate</button>
                </div>
            </div>

            <div class="muted">
                Limits apply when you send commands in this app and will be saved to
                <code>config/config_file.json</code>.
            </div>
        </div>

        <div class="bar">

            <!-- Left half: servo selection + channel dropdown in middle gap -->
            <div class="card selectorWrap">
                <div class="row">
                    <div style="font-weight:900;">Servo select</div>
                    <div class="muted" id="selectedShort">None</div>
                </div>

                <div class="selectorTopLabels">
                    <div class="lr" style="grid-column:1 / span 2;">Left</div>
                    <div></div>
                    <div class="lr" style="grid-column:4 / span 2;">Right</div>
                </div>

                <div class="selectorGridArea">
                    <!-- Front row label -->
                    <div class="rowLabel" style="grid-row:1;">Front</div>

                    <button id="btn_front_left_knee" class="servoBtn" style="grid-row:1;grid-column:2;">knee</button>
                    <button id="btn_front_left_hip" class="servoBtn" style="grid-row:1;grid-column:3;">hip</button>

                    <div class="channelBlock">
                        <label>channel</label>
                        <select id="channelSelect"></select>
                    </div>

                    <button id="btn_front_right_hip" class="servoBtn" style="grid-row:1;grid-column:5;">hip</button>
                    <button id="btn_front_right_knee" class="servoBtn" style="grid-row:1;grid-column:6;">knee</button>

                    <!-- Rear row label -->
                    <div class="rowLabel" style="grid-row:2;">Rear</div>

                    <button id="btn_rear_left_knee" class="servoBtn" style="grid-row:2;grid-column:2;">knee</button>
                    <button id="btn_rear_left_hip" class="servoBtn" style="grid-row:2;grid-column:3;">hip</button>

                    <button id="btn_rear_right_hip" class="servoBtn" style="grid-row:2;grid-column:5;">hip</button>
                    <button id="btn_rear_right_knee" class="servoBtn" style="grid-row:2;grid-column:6;">knee</button>
                </div>

                <div class="muted">
                    Select a servo, then assign its PCA channel using the dropdown.
                </div>
            </div>

            <!-- Right half: angle control -->
            <div class="card angleWrap">
                <div class="row" style="align-items:flex-start;">
                    <div>
                        <div style="font-weight:900;">Angle control</div>
                        <div class="muted">0–270</div>
                    </div>

                    <div class="radioRow">
                        <span class="muted" style="font-weight:900;">Mode</span>
                        <label class="radioPill">
                            <input type="radio" name="mode" id="modeNormal" value="normal">
                            <span>Normal</span>
                        </label>
                        <label class="radioPill">
                            <input type="radio" name="mode" id="modeTest" value="test">
                            <span>Test</span>
                        </label>
                    </div>
                </div>

                <div class="angleRow">
                    <div class="steps" id="negSteps"></div>

                    <div class="angleBox">
                        <input id="angleInput" type="text" inputmode="numeric" value="0" />
                        <button id="sendBtn" class="primary">Send</button>
                    </div>

                    <div class="steps" id="posSteps"></div>
                </div>

                <div class="hotkeys" id="hotkeyButtons"></div>

                <div class="muted" id="cmdStatus">—</div>
            </div>

        </div>
    </div>

    <script>
        /* -------------------- State -------------------- */
        let locations = [];
        let draft = null;
        let availableChannels = [];
        let selectedLocation = null;

        // dynamic limit variables + state angles from backend
        let dynVars = null;
        let hwAngles = {};
        let simAngles = {};
        let collisionStatus = null;
        let stances = [];

        // UI mode
        const MODE_KEY = "doggo:mode:v1";
        let mode = "normal"; // "normal" | "test"

        // Per-location last commanded angle (persisted)
        const LAST_ANGLES_KEY = "doggo:lastAngles:v1";
        let lastAngles = {};

        // Hotkeys (persisted)
        const HOTKEYS_KEY = "doggo:hotkeys:v1";
        let hotkeys = [0, 70, 135, 200, 250, 270];

        let currentAngle = 0;
        const steps = [1, 5, 10];

        // Button mapping (per your specified order)
        const BUTTON_TO_LOCATION = {
            btn_front_left_knee: "front_left_knee",
            btn_front_left_hip: "front_left_hip",
            btn_front_right_hip: "front_right_hip",
            btn_front_right_knee: "front_right_knee",

            btn_rear_left_knee: "rear_left_knee",
            btn_rear_left_hip: "rear_left_hip",
            btn_rear_right_hip: "rear_right_hip",
            btn_rear_right_knee: "rear_right_knee",
        };

        /* -------------------- API helpers -------------------- */
        async function api(url, method = "GET", body = null) {
            const opts = { method, headers: {} };
            if (body) {
                opts.headers["Content-Type"] = "application/json";
                opts.body = JSON.stringify(body);
            }
            const res = await fetch(url, opts);
            const data = await res.json();
            return { ok: res.ok, status: res.status, data };
        }

        function renderStanceSelect(defaultName = "default") {
            const sel = document.getElementById("stanceSelect");
            const btn = document.getElementById("activateStanceBtn");
            sel.innerHTML = "";

            if (!stances.length) {
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "No stances found";
                sel.appendChild(opt);
                sel.disabled = true;
                btn.disabled = true;
                return;
            }

            for (const s of stances) {
                const opt = document.createElement("option");
                opt.value = s.name;
                opt.textContent = s.file || `${s.name}.json`;
                sel.appendChild(opt);
            }

            const preferred = stances.find(s => s.name === defaultName);
            sel.value = preferred ? preferred.name : stances[0].name;
            sel.disabled = false;
            btn.disabled = false;
        }

        async function loadStances() {
            const resp = await api("/api/stances");
            if (!resp.ok) {
                stances = [];
                renderStanceSelect();
                setCmdStatus(`Failed to load stances (${resp.status})`, "danger");
                return;
            }
            stances = Array.isArray(resp.data.stances) ? resp.data.stances : [];
            renderStanceSelect(resp.data.default_stance || "default");
        }

        /* -------------------- Persistence -------------------- */
        function loadLastAngles() {
            try {
                const s = localStorage.getItem(LAST_ANGLES_KEY);
                lastAngles = s ? JSON.parse(s) : {};
                if (typeof lastAngles !== "object" || lastAngles === null) lastAngles = {};
            } catch {
                lastAngles = {};
            }
        }

        function saveLastAngles() {
            try { localStorage.setItem(LAST_ANGLES_KEY, JSON.stringify(lastAngles)); } catch { }
        }

        function loadHotkeys() {
            try {
                const s = localStorage.getItem(HOTKEYS_KEY);
                const arr = s ? JSON.parse(s) : null;
                if (Array.isArray(arr) && arr.length === 6) {
                    hotkeys = arr.map(v => clampInt(toInt(v, 0), 0, 270));
                }
            } catch { }
        }

        function saveHotkeys() {
            try { localStorage.setItem(HOTKEYS_KEY, JSON.stringify(hotkeys)); } catch { }
        }

        function loadMode() {
            try {
                const s = localStorage.getItem(MODE_KEY);
                if (s === "normal" || s === "test") mode = s;
            } catch { }
        }

        function saveMode() {
            try { localStorage.setItem(MODE_KEY, mode); } catch { }
        }

        /* -------------------- Utils -------------------- */
        function clampInt(v, lo, hi) {
            return Math.max(lo, Math.min(hi, v));
        }

        function toInt(v, fallback = null) {
            const n = Number.parseInt(String(v).trim(), 10);
            return Number.isFinite(n) ? n : fallback;
        }

        function toFloat(v, fallback = null) {
            const n = Number.parseFloat(String(v).trim());
            return Number.isFinite(n) ? n : fallback;
        }

        function isStrictIntegerString(s) {
            return /^[0-9]+$/.test(s);
        }

        function setAngleInput(v) {
            const el = document.getElementById("angleInput");
            el.value = String(v);
            currentAngle = v;
        }

        function getAngleFromInput() {
            const el = document.getElementById("angleInput");
            const raw = String(el.value ?? "").trim();
            if (!isStrictIntegerString(raw)) return { ok: false, error: "Angle must be digits only (0..270)." };
            const n = toInt(raw, null);
            if (n === null) return { ok: false, error: "Angle must be an integer." };
            if (n < 0 || n > 270) return { ok: false, error: "Angle out of range (0..270)." };
            return { ok: true, value: n };
        }

        function locLabel(locKey) {
            const loc = locations.find(l => l.key === locKey);
            return loc ? loc.label : locKey;
        }

        function currentStateAngles() {
            return mode === "test" ? simAngles : hwAngles;
        }

        function activeSide() {
            if (!dynVars) return "left";
            const a = String(dynVars.active_side || "left").toLowerCase();
            return (a === "right") ? "right" : "left";
        }

        function setCmdStatus(text, cls = "muted") {
            const el = document.getElementById("cmdStatus");
            el.className = cls;
            el.textContent = text;
        }

        function initCollapsibleSections() {
            const KEY = "doggo:sidebarCollapsed:v1";
            let saved = {};
            try { saved = JSON.parse(localStorage.getItem(KEY) || "{}") || {}; } catch { saved = {}; }
            document.querySelectorAll(".sidebarSection").forEach((section, idx) => {
                const title = section.querySelector(".sectionTitle");
                if (!title) return;
                const sid = title.textContent.trim().toLowerCase().replace(/[^a-z0-9]+/g, "_") || `section_${idx}`;
                section.dataset.sid = sid;
                if (saved[sid] === true) section.classList.add("collapsed");
                title.addEventListener("click", () => {
                    section.classList.toggle("collapsed");
                    saved[sid] = section.classList.contains("collapsed");
                    try { localStorage.setItem(KEY, JSON.stringify(saved)); } catch { }
                });
            });
        }

        /* -------------------- Sidebar + selection -------------------- */
        function setSaveResetEnabled(saveEnabled, resetEnabled) {
            document.getElementById("saveBtn").disabled = !saveEnabled;
            document.getElementById("resetBtn").disabled = !resetEnabled;
        }

        function syncSelectedSidebar() {
            const labelEl = document.getElementById("selectedLabel");
            const shortEl = document.getElementById("selectedShort");
            const minEl = document.getElementById("minDeg");
            const maxEl = document.getElementById("maxDeg");
            const invEl = document.getElementById("invertChk");

            if (!selectedLocation || !draft) {
                labelEl.textContent = "None";
                shortEl.textContent = "None";
                minEl.value = "";
                maxEl.value = "";
                invEl.checked = false;
                minEl.disabled = true;
                maxEl.disabled = true;
                invEl.disabled = true;
                return;
            }

            labelEl.textContent = locLabel(selectedLocation);
            shortEl.textContent = locLabel(selectedLocation);

            const lim = draft.locations[selectedLocation].limits;
            minEl.value = String(lim.deg_min);
            maxEl.value = String(lim.deg_max);
            invEl.checked = !!lim.invert;

            minEl.disabled = false;
            maxEl.disabled = false;
            invEl.disabled = false;
        }

        function renderServoButtons() {
            for (const [btnId, locKey] of Object.entries(BUTTON_TO_LOCATION)) {
                const btn = document.getElementById(btnId);
                if (!btn) continue;
                btn.classList.toggle("selected", selectedLocation === locKey);
            }
        }

        function buildChannelSelectOptions() {
            const sel = document.getElementById("channelSelect");
            sel.innerHTML = "";

            // Unassigned option
            const optNone = document.createElement("option");
            optNone.value = "";
            optNone.textContent = "— Unassigned —";
            sel.appendChild(optNone);

            if (!selectedLocation || !draft) {
                sel.value = "";
                sel.disabled = true;
                return;
            }

            sel.disabled = false;

            const current = draft.locations[selectedLocation].channel; // may be null
            const pool = [...(availableChannels || [])];

            if (current !== null && current !== undefined && !pool.includes(current)) pool.push(current);
            pool.sort((a, b) => a - b);

            pool.forEach(ch => {
                const o = document.createElement("option");
                o.value = String(ch);
                o.textContent = `Channel ${ch}`;
                sel.appendChild(o);
            });

            sel.value = (current === null || current === undefined) ? "" : String(current);
        }

        function applySelection(locKey) {
            selectedLocation = locKey;
            syncSelectedSidebar();
            renderServoButtons();
            buildChannelSelectOptions();

            // Fill angle input from current state for mode (preferred)
            const st = currentStateAngles();
            if (st && st[selectedLocation] !== undefined) {
                const v = clampInt(toInt(st[selectedLocation], 135), 0, 270);
                setAngleInput(v);
                return;
            }

            // Fallback: per-location lastAngles
            if (lastAngles[selectedLocation] !== undefined) {
                const v = clampInt(toInt(lastAngles[selectedLocation], 0), 0, 270);
                setAngleInput(v);
            }
        }

        /* -------------------- Limits API -------------------- */
        async function pushLimits() {
            if (!selectedLocation) return;

            const minEl = document.getElementById("minDeg");
            const maxEl = document.getElementById("maxDeg");
            const invEl = document.getElementById("invertChk");

            const deg_min = parseInt(minEl.value, 10);
            const deg_max = parseInt(maxEl.value, 10);
            const invert = !!invEl.checked;

            const resp = await api("/api/limits", "POST", { location: selectedLocation, deg_min, deg_max, invert });
            if (!resp.ok) {
                alert(resp.data.error || "Failed to set limits");
                return;
            }
            draft = resp.data.draft;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
            syncSelectedSidebar();
        }

        /* -------------------- Command path -------------------- */
        async function sendAngle(angle) {
            if (!selectedLocation) {
                alert("Select a servo first.");
                return;
            }

            setCmdStatus(`${mode === "test" ? "Test" : "Normal"}: sending…`, "muted");
            const resp = await api("/api/command", "POST", { location: selectedLocation, angle_deg: angle, mode });
            if (!resp.ok) {
                alert(resp.data.error || "Command failed");
                setCmdStatus("Command failed", "danger");
                return;
            }

            const applied = clampInt(toInt(resp.data.applied_angle, angle), 0, 270);

            // Reflect the actual logical angle applied by the backend clamp pipeline.
            const displayAngle = applied;
            setAngleInput(displayAngle);
            lastAngles[selectedLocation] = displayAngle;
            saveLastAngles();

            // Refresh state angles from response path:
            // server mutates hw_angles or sim_angles; easiest is to refresh config snapshot
            await refreshAnglesOnly();

            // Status
            if (resp.data.clamped) {
                const det = resp.data.collision ? `${resp.data.collision.pair} (d=${resp.data.collision.min_distance_mm?.toFixed?.(2) ?? "?"} <= ${resp.data.collision.threshold_mm?.toFixed?.(2) ?? "?"})` : "collision";
                setCmdStatus(`Clamped → ${applied}° (${det})`, "danger");
            } else {
                setCmdStatus(`Applied → ${applied}°`, "ok");
            }

            // Re-render viz
            renderViz();
        }

        async function activateStance() {
            const sel = document.getElementById("stanceSelect");
            const stance = String(sel.value || "").trim();
            if (!stance) {
                alert("Select a stance first.");
                return;
            }

            setCmdStatus(`${mode === "test" ? "Test" : "Normal"}: activating stance '${stance}'…`, "muted");
            const resp = await api("/api/stance/activate", "POST", { stance, mode });
            if (!resp.ok || !resp.data?.ok) {
                const msg = resp.data?.error || `HTTP ${resp.status}`;
                setCmdStatus(`Stance '${stance}' failed: ${msg}`, "danger");
                await refreshAnglesOnly();
                return;
            }

            const count = Number(resp.data.completed_count || 0);
            const delay = Number(resp.data.delay_ms || 0);
            setCmdStatus(`Stance '${stance}' applied (${count} joints @ ${delay}ms step)`, "ok");

            await refreshAnglesOnly();
            if (selectedLocation) {
                applySelection(selectedLocation);
            }
        }

        async function adjustAngle(delta) {
            if (!selectedLocation) {
                alert("Select a servo first.");
                return;
            }
            const next = clampInt(currentAngle + delta, 0, 270);
            setAngleInput(next);
            await sendAngle(next);
        }

        /* -------------------- Angle control rendering -------------------- */
        function renderControlBar() {
            const neg = document.getElementById("negSteps");
            const pos = document.getElementById("posSteps");
            neg.innerHTML = "";
            pos.innerHTML = "";

            steps.slice().reverse().forEach(s => {
                const b = document.createElement("button");
                b.textContent = `-${s}`;
                b.addEventListener("click", () => adjustAngle(-s));
                neg.appendChild(b);
            });

            steps.forEach(s => {
                const b = document.createElement("button");
                b.textContent = `+${s}`;
                b.addEventListener("click", () => adjustAngle(+s));
                pos.appendChild(b);
            });

            renderHotkeyButtons();
        }

        function renderHotkeyButtons() {
            const host = document.getElementById("hotkeyButtons");
            host.innerHTML = "";
            hotkeys.forEach((v, idx) => {
                const b = document.createElement("button");
                b.className = "tiny";
                b.textContent = `${v}°`;
                b.title = `Hotkey ${idx + 1}: send ${v}°`;
                b.addEventListener("click", async () => {
                    if (!selectedLocation) {
                        alert("Select a servo first.");
                        return;
                    }
                    setAngleInput(v);
                    await sendAngle(v);
                });
                host.appendChild(b);
            });
        }

        function attachSelectOverwrite(ids) {
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                el.addEventListener("focus", () => el.select());
                el.addEventListener("click", () => el.select());
            });
        }

        /* -------------------- Hotkeys programmable inputs -------------------- */
        function syncHotkeyInputs() {
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById(`hk${i}`);
                el.value = String(hotkeys[i]);
            }
        }

        function attachHotkeyInputHandlers() {
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById(`hk${i}`);
                el.addEventListener("change", () => {
                    const v = clampInt(toInt(el.value, hotkeys[i]), 0, 270);
                    hotkeys[i] = v;
                    el.value = String(v);
                    saveHotkeys();
                    renderHotkeyButtons();
                });
            }
        }

        /* -------------------- Notes -------------------- */
        let notesSaveTimer = null;
        let notesLastSent = null;

        function setNotesStatus(text, cls = "muted") {
            const el = document.getElementById("notesStatus");
            el.className = cls;
            el.textContent = text;
        }

        async function loadNotes() {
            const resp = await api("/api/channel_notes");
            if (!resp.ok) {
                setNotesStatus("Notes: failed to load", "danger");
                return;
            }
            const notes = (resp.data && typeof resp.data.notes === "string") ? resp.data.notes : "";
            const area = document.getElementById("notesArea");
            area.value = notes;
            notesLastSent = notes;
            setNotesStatus("Notes: loaded", "muted");
        }

        function scheduleNotesSave() {
            if (notesSaveTimer) clearTimeout(notesSaveTimer);
            notesSaveTimer = setTimeout(async () => {
                const area = document.getElementById("notesArea");
                const notes = String(area.value ?? "");
                if (notes === notesLastSent) return;

                setNotesStatus("Notes: saving…", "muted");
                const resp = await api("/api/channel_notes", "POST", { notes });
                if (!resp.ok) {
                    setNotesStatus(`Notes: save failed (${resp.data?.error || resp.status})`, "danger");
                    return;
                }
                notesLastSent = notes;
                setNotesStatus("Notes: saved", "ok");
            }, 500);
        }

        /* -------------------- Dynamic vars editor -------------------- */
        let dlSaveTimer = null;
        let dlLastSentStr = null;

        function setDlStatus(text, cls = "muted") {
            const el = document.getElementById("dl_status");
            el.className = cls;
            el.textContent = text;
        }

        function setSideRadio(side) {
            if (side === "right") {
                document.getElementById("sideRight").checked = true;
            } else {
                document.getElementById("sideLeft").checked = true;
            }
            document.getElementById("dl_side_label").textContent = side;
        }

        function ensureCalibrationModel() {
            if (!dynVars) return;
            if (!dynVars.calibration_profiles || typeof dynVars.calibration_profiles !== "object") {
                dynVars.calibration_profiles = {};
            }
            if (!dynVars.calibration_profiles.identity) {
                dynVars.calibration_profiles.identity = {
                    fit_mode: "linear_best_fit",
                    measurement_mode: "servo_physical_deg",
                    pairs: [
                        { commanded_deg: 0, actual_deg: 0 },
                        { commanded_deg: 270, actual_deg: 270 },
                    ],
                };
            }
            if (!dynVars.calibration_profiles.hip_standard) {
                dynVars.calibration_profiles.hip_standard = {
                    fit_mode: "linear_best_fit",
                    measurement_mode: "hip_line_relative_deg",
                    pairs: [
                        { commanded_deg: 163, actual_deg: 90 },
                        { commanded_deg: 135, actual_deg: 135 },
                    ],
                };
            }
            if (!dynVars.calibration_profiles.knee_standard) {
                dynVars.calibration_profiles.knee_standard = {
                    fit_mode: "linear_best_fit",
                    measurement_mode: "knee_relative_deg",
                    pairs: [
                        { commanded_deg: 163, actual_deg: 90 },
                        { commanded_deg: 30, actual_deg: 180 },
                    ],
                };
            }
            for (const [name, prof] of Object.entries(dynVars.calibration_profiles)) {
                if (!prof || typeof prof !== "object") {
                    dynVars.calibration_profiles[name] = { fit_mode: "linear_best_fit", measurement_mode: "servo_physical_deg", pairs: [] };
                    continue;
                }
                if (!["servo_physical_deg", "hip_line_relative_deg", "knee_relative_deg"].includes(String(prof.measurement_mode || ""))) {
                    prof.measurement_mode = "servo_physical_deg";
                }
                if (!Array.isArray(prof.pairs)) prof.pairs = [];
            }
            if (!dynVars.joint_calibration_map || typeof dynVars.joint_calibration_map !== "object") {
                dynVars.joint_calibration_map = {};
            }
            for (const loc of locations) {
                if (!dynVars.joint_calibration_map[loc.key] || !dynVars.calibration_profiles[dynVars.joint_calibration_map[loc.key]]) {
                    dynVars.joint_calibration_map[loc.key] = "identity";
                }
            }
            if (!dynVars.sim_rotation_flip_map || typeof dynVars.sim_rotation_flip_map !== "object") {
                dynVars.sim_rotation_flip_map = {};
            }
            for (const loc of locations) {
                dynVars.sim_rotation_flip_map[loc.key] = Boolean(dynVars.sim_rotation_flip_map[loc.key]);
            }
        }

        function calibrationProfileNames() {
            ensureCalibrationModel();
            return Object.keys(dynVars.calibration_profiles || {}).sort();
        }

        function selectedCalibrationProfileName() {
            const sel = document.getElementById("cal_profile_select");
            const names = calibrationProfileNames();
            if (!names.length) return "identity";
            const cur = String(sel.value || "").trim();
            return names.includes(cur) ? cur : names[0];
        }

        function fitLinearFromPairs(pairs) {
            if (!Array.isArray(pairs) || pairs.length < 2) return null;
            const xs = [];
            const ys = [];
            for (const p of pairs) {
                if (!p || typeof p !== "object") continue;
                const x = toFloat(p.commanded_deg, null);
                const y = toFloat(p.actual_deg, null);
                if (x === null || y === null) continue;
                xs.push(x);
                ys.push(y);
            }
            if (xs.length < 2) return null;
            const n = xs.length;
            const xMean = xs.reduce((a, b) => a + b, 0) / n;
            const yMean = ys.reduce((a, b) => a + b, 0) / n;
            let varX = 0;
            let covXY = 0;
            let sst = 0;
            let sse = 0;
            for (let i = 0; i < n; i++) {
                varX += (xs[i] - xMean) * (xs[i] - xMean);
                covXY += (xs[i] - xMean) * (ys[i] - yMean);
            }
            if (varX <= 1e-9) return null;
            const m = covXY / varX;
            const b = yMean - m * xMean;
            for (let i = 0; i < n; i++) {
                const yHat = m * xs[i] + b;
                sse += (ys[i] - yHat) * (ys[i] - yHat);
                sst += (ys[i] - yMean) * (ys[i] - yMean);
            }
            const r2 = sst <= 1e-9 ? 1.0 : (1.0 - sse / sst);
            return { m, b, r2, n };
        }

        function renderCalibrationUi() {
            if (!dynVars) return;
            ensureCalibrationModel();

            const profileSel = document.getElementById("cal_profile_select");
            const names = calibrationProfileNames();
            const prev = String(profileSel.value || "");
            profileSel.innerHTML = "";
            for (const name of names) {
                const opt = document.createElement("option");
                opt.value = name;
                opt.textContent = name;
                profileSel.appendChild(opt);
            }
            profileSel.value = names.includes(prev) ? prev : (names[0] || "identity");

            const active = selectedCalibrationProfileName();
            const profile = dynVars.calibration_profiles[active] || { pairs: [] };
            const modeSel = document.getElementById("cal_mode_select");
            modeSel.value = ["servo_physical_deg", "hip_line_relative_deg", "knee_relative_deg"].includes(profile.measurement_mode)
                ? profile.measurement_mode
                : "servo_physical_deg";
            const pairs = Array.isArray(profile.pairs) ? profile.pairs : [];

            const fit = fitLinearFromPairs(pairs);
            const fitEl = document.getElementById("cal_fit_summary");
            const modeLabel = modeSel.value === "hip_line_relative_deg"
                ? "hip-line-relative"
                : (modeSel.value === "knee_relative_deg" ? "knee-relative" : "servo-physical");
            if (!fit) {
                fitEl.textContent = `Mode=${modeLabel}. Need at least 2 points for fit.`;
            } else {
                fitEl.textContent = `Mode=${modeLabel}. Fit: actual = ${fit.m.toFixed(4)}*commanded + ${fit.b.toFixed(2)} (R²=${fit.r2.toFixed(4)}, n=${fit.n})`;
            }

            const pairsWrap = document.getElementById("cal_pairs_list");
            pairsWrap.innerHTML = "";
            if (!pairs.length) {
                const empty = document.createElement("div");
                empty.className = "muted";
                empty.textContent = "No pairs in this profile.";
                pairsWrap.appendChild(empty);
            } else {
                pairs.forEach((p, idx) => {
                    const row = document.createElement("div");
                    row.className = "pairRow";
                    const c = document.createElement("div");
                    c.className = "mono";
                    c.textContent = Number(p.commanded_deg).toFixed(1);
                    const a = document.createElement("div");
                    a.className = "mono";
                    a.textContent = Number(p.actual_deg).toFixed(1);
                    const rm = document.createElement("button");
                    rm.className = "tiny";
                    rm.textContent = "Remove";
                    rm.addEventListener("click", () => {
                        profile.pairs.splice(idx, 1);
                        scheduleDynVarsSave();
                        renderCalibrationUi();
                        renderViz();
                    });
                    row.appendChild(c);
                    row.appendChild(a);
                    row.appendChild(rm);
                    pairsWrap.appendChild(row);
                });
            }

            const mapWrap = document.getElementById("cal_joint_map");
            mapWrap.innerHTML = "";
            for (const loc of locations) {
                const row = document.createElement("div");
                row.className = "row";
                const lab = document.createElement("label");
                lab.className = "muted";
                lab.textContent = loc.label;
                lab.htmlFor = `cal_map_${loc.key}`;
                const sel = document.createElement("select");
                sel.id = `cal_map_${loc.key}`;
                for (const name of names) {
                    const opt = document.createElement("option");
                    opt.value = name;
                    opt.textContent = name;
                    sel.appendChild(opt);
                }
                const assigned = dynVars.joint_calibration_map[loc.key] || "identity";
                sel.value = names.includes(assigned) ? assigned : "identity";
                sel.addEventListener("change", () => {
                    dynVars.joint_calibration_map[loc.key] = sel.value;
                    scheduleDynVarsSave();
                    renderViz();
                });
                row.appendChild(lab);
                row.appendChild(sel);
                mapWrap.appendChild(row);
            }

            const flipWrap = document.getElementById("sim_flip_map");
            flipWrap.innerHTML = "";
            for (const loc of locations) {
                const row = document.createElement("div");
                row.className = "row";
                const lab = document.createElement("label");
                lab.className = "muted";
                lab.textContent = loc.label;
                lab.htmlFor = `sim_flip_${loc.key}`;
                const chk = document.createElement("input");
                chk.id = `sim_flip_${loc.key}`;
                chk.type = "checkbox";
                chk.checked = Boolean(dynVars.sim_rotation_flip_map[loc.key]);
                chk.addEventListener("change", () => {
                    dynVars.sim_rotation_flip_map[loc.key] = chk.checked;
                    scheduleDynVarsSave();
                    renderViz();
                });
                row.appendChild(lab);
                row.appendChild(chk);
                flipWrap.appendChild(row);
            }
        }

        function syncDynVarsInputs() {
            if (!dynVars) return;
            ensureCalibrationModel();
            const side = activeSide();
            setSideRadio(side);

            // globals
            document.getElementById("dl_step").value = String(dynVars.search_step_deg ?? 1);
            document.getElementById("dl_iters").value = String(dynVars.search_max_iters ?? 300);

            const s = dynVars[side] || {};
            document.getElementById("dl_hip_dx").value = String(s.hip_dx_mm ?? 80);
            document.getElementById("dl_hip_y").value = String(s.hip_y_mm ?? 60);

            document.getElementById("dl_ltf").value = String(s.thigh_len_front_mm ?? 70);
            document.getElementById("dl_lsf").value = String(s.shin_len_front_mm ?? 90);
            document.getElementById("dl_ltr").value = String(s.thigh_len_rear_mm ?? 70);
            document.getElementById("dl_lsr").value = String(s.shin_len_rear_mm ?? 90);
            document.getElementById("dl_kab_f").value = String(s.front_knee_attach_backoff_mm ?? 0);
            document.getElementById("dl_kab_r").value = String(s.rear_knee_attach_backoff_mm ?? 0);

            document.getElementById("dl_r_ft").value = String(s.front_thigh_radius_mm ?? 6);
            document.getElementById("dl_r_fs").value = String(s.front_shin_radius_mm ?? 6);
            document.getElementById("dl_r_rt").value = String(s.rear_thigh_radius_mm ?? 6);
            document.getElementById("dl_r_rs").value = String(s.rear_shin_radius_mm ?? 6);

            document.getElementById("dl_off_fh").value = String(s.front_hip_offset_deg ?? 0);
            document.getElementById("dl_off_fk").value = String(s.front_knee_offset_deg ?? 0);
            document.getElementById("dl_off_rh").value = String(s.rear_hip_offset_deg ?? 0);
            document.getElementById("dl_off_rk").value = String(s.rear_knee_offset_deg ?? 0);
            renderCalibrationUi();
        }

        function readDynVarsInputsIntoModel() {
            if (!dynVars) return;

            // globals
            const step = clampInt(toInt(document.getElementById("dl_step").value, dynVars.search_step_deg ?? 1), 1, 45);
            const iters = clampInt(toInt(document.getElementById("dl_iters").value, dynVars.search_max_iters ?? 300), 1, 5000);
            dynVars.search_step_deg = step;
            dynVars.search_max_iters = iters;

            // active side label already set by radios; ensure dynVars.active_side is correct
            dynVars.active_side = activeSide();

            const side = activeSide();
            dynVars[side] = dynVars[side] || {};

            const s = dynVars[side];
            const f = (id, key) => {
                const v = toFloat(document.getElementById(id).value, s[key] ?? 0);
                s[key] = v;
            };

            f("dl_hip_dx", "hip_dx_mm");
            f("dl_hip_y", "hip_y_mm");

            f("dl_ltf", "thigh_len_front_mm");
            f("dl_lsf", "shin_len_front_mm");
            f("dl_ltr", "thigh_len_rear_mm");
            f("dl_lsr", "shin_len_rear_mm");
            f("dl_kab_f", "front_knee_attach_backoff_mm");
            f("dl_kab_r", "rear_knee_attach_backoff_mm");

            f("dl_r_ft", "front_thigh_radius_mm");
            f("dl_r_fs", "front_shin_radius_mm");
            f("dl_r_rt", "rear_thigh_radius_mm");
            f("dl_r_rs", "rear_shin_radius_mm");

            f("dl_off_fh", "front_hip_offset_deg");
            f("dl_off_fk", "front_knee_offset_deg");
            f("dl_off_rh", "rear_hip_offset_deg");
            f("dl_off_rk", "rear_knee_offset_deg");
        }

        function scheduleDynVarsSave() {
            if (!dynVars) return;
            if (dlSaveTimer) clearTimeout(dlSaveTimer);

            dlSaveTimer = setTimeout(async () => {
                readDynVarsInputsIntoModel();

                const payload = { dynamic_limits: dynVars };
                const s = JSON.stringify(payload);
                if (s === dlLastSentStr) return;

                setDlStatus("Saving…", "muted");
                const resp = await api("/api/dynamic_limits", "POST", payload);
                if (!resp.ok) {
                    setDlStatus(`Save failed (${resp.data?.error || resp.status})`, "danger");
                    return;
                }
                dynVars = resp.data.dynamic_limits;
                dlLastSentStr = JSON.stringify({ dynamic_limits: dynVars });
                setDlStatus("Saved", "ok");

                // keep UI consistent with server canonical values
                syncDynVarsInputs();
                renderViz();
            }, 350);
        }

        /* -------------------- Mode handling -------------------- */
        function setModeRadios() {
            document.getElementById("modeNormal").checked = (mode === "normal");
            document.getElementById("modeTest").checked = (mode === "test");
        }

        function restoreUiToActualStateAfterModeSwitch() {
            // On switching to normal: restore to hw angles
            // On switching to test: restore to sim angles
            const st = currentStateAngles();

            if (selectedLocation && st && st[selectedLocation] !== undefined) {
                const v = clampInt(toInt(st[selectedLocation], 135), 0, 270);
                setAngleInput(v);
                lastAngles[selectedLocation] = v;
                saveLastAngles();
            }
            renderViz();
        }

        /* -------------------- Visualization (canvas) -------------------- */
        function resizeCanvasToDisplaySize(canvas) {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const w = Math.max(1, Math.floor(rect.width * dpr));
            const h = Math.max(1, Math.floor(rect.height * dpr));
            if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
                return true;
            }
            return false;
        }

        function degToRad(deg) {
            return deg * Math.PI / 180.0;
        }

        function unitFromAngleDeg(deg) {
            const r = degToRad(deg);
            // Keep frontend kinematics aligned with backend collision math:
            // 0 deg points rear, 180 deg points front, positive rotates clockwise.
            return { x: -Math.cos(r), y: -Math.sin(r) };
        }

        function unitFromKneeAngleDeg(deg) {
            const r = degToRad(deg);
            // Knee winding is opposite to hip winding in the sim model.
            return { x: -Math.cos(r), y: Math.sin(r) };
        }

        function add(a, b) { return { x: a.x + b.x, y: a.y + b.y }; }
        function mul(a, s) { return { x: a.x * s, y: a.y * s }; }
        function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

        function angleBetweenSegmentsDeg(a0, a1, b0, b1) {
            const ux = a1.x - a0.x, uy = a1.y - a0.y;
            const vx = b1.x - b0.x, vy = b1.y - b0.y;
            const un = Math.hypot(ux, uy);
            const vn = Math.hypot(vx, vy);
            if (un < 1e-9 || vn < 1e-9) return 0;
            const dot = (ux * vx + uy * vy) / (un * vn);
            return Math.acos(clamp(dot, -1, 1)) * 180.0 / Math.PI;
        }

        function segmentRelativeDeg(a, b, c) {
            // Joint interior angle at B between thigh and shin:
            // use vectors BA (knee->hip) and BC (knee->foot).
            const ux = a.x - b.x, uy = a.y - b.y;
            const vx = c.x - b.x, vy = c.y - b.y;
            const un = Math.hypot(ux, uy);
            const vn = Math.hypot(vx, vy);
            if (un < 1e-9 || vn < 1e-9) return 0;
            const dot = (ux * vx + uy * vy) / (un * vn);
            return Math.acos(clamp(dot, -1, 1)) * 180.0 / Math.PI;
        }

        function rotateCcwDeg(v, deg) {
            const r = degToRad(deg);
            const c = Math.cos(r);
            const s = Math.sin(r);
            return { x: v.x * c - v.y * s, y: v.x * s + v.y * c };
        }

        function normalizeDeg(deg) {
            let x = deg % 360;
            if (x < 0) x += 360;
            return x;
        }

        function angleFromHipUnit(u) {
            return normalizeDeg(Math.atan2(-u.y, -u.x) * 180.0 / Math.PI);
        }

        function angleFromKneeLocalUnit(v) {
            return normalizeDeg(Math.atan2(v.y, -v.x) * 180.0 / Math.PI);
        }

        function calibratedMeasurementForViz(locKey, physicalAngle) {
            const profiles = dynVars?.calibration_profiles;
            const jmap = dynVars?.joint_calibration_map;
            const flipMap = dynVars?.sim_rotation_flip_map;
            const flippedPhysical = (flipMap && flipMap[locKey]) ? (270 - physicalAngle) : physicalAngle;
            if (!profiles || typeof profiles !== "object") return { mode: "servo_physical_deg", value: flippedPhysical };
            let profName = String((jmap && jmap[locKey]) || "identity");
            if (!profiles[profName]) profName = "identity";
            const prof = profiles[profName];
            if (!prof || typeof prof !== "object") return { mode: "servo_physical_deg", value: physicalAngle };
            const mode = ["servo_physical_deg", "hip_line_relative_deg", "knee_relative_deg"].includes(String(prof.measurement_mode))
                ? String(prof.measurement_mode)
                : "servo_physical_deg";
            const fit = fitLinearFromPairs(Array.isArray(prof.pairs) ? prof.pairs : []);
            if (!fit) return { mode, value: flippedPhysical };
            return { mode, value: Math.max(0, Math.min(270, fit.m * flippedPhysical + fit.b)) };
        }

        function getSideJointInputs(side, state) {
            const s = state || {};
            const locLimits = (locKey) => (draft?.locations?.[locKey]?.limits) || {};
            function physicalForViz(locKey, logicalAngle) {
                const lim = locLimits(locKey);
                const raw = clampInt(toInt(logicalAngle, 135), 0, 270);
                let lo = clampInt(toInt(lim.deg_min, 0), 0, 270);
                let hi = clampInt(toInt(lim.deg_max, 270), 0, 270);
                if (hi < lo) { const t = lo; lo = hi; hi = t; }
                const logical = clampInt(raw, lo, hi);
                return (lim.invert === true) ? (270 - logical) : logical;
            }
            function jointIn(locKey, logicalAngle) {
                const physical = physicalForViz(locKey, logicalAngle);
                const cal = calibratedMeasurementForViz(locKey, physical);
                return { physical, mode: cal.mode, measured: cal.value };
            }
            if (side === "right") {
                return {
                    front_hip: jointIn("front_right_hip", s.front_right_hip),
                    front_knee: jointIn("front_right_knee", s.front_right_knee),
                    rear_hip: jointIn("rear_right_hip", s.rear_right_hip),
                    rear_knee: jointIn("rear_right_knee", s.rear_right_knee),
                };
            }
            return {
                front_hip: jointIn("front_left_hip", s.front_left_hip),
                front_knee: jointIn("front_left_knee", s.front_left_knee),
                rear_hip: jointIn("rear_left_hip", s.rear_left_hip),
                rear_knee: jointIn("rear_left_knee", s.rear_left_knee),
            };
        }

        function buildVizGeometry() {
            if (!dynVars) return null;

            const side = activeSide();
            const s = dynVars[side] || {};
            const st = currentStateAngles();
            const j = getSideJointInputs(side, st);

            const hip_dx = Number(s.hip_dx_mm ?? 80);
            const hip_y = Number(s.hip_y_mm ?? 60);

            const Ltf = Number(s.thigh_len_front_mm ?? 70);
            const Lsf = Number(s.shin_len_front_mm ?? 90);
            const Ltr = Number(s.thigh_len_rear_mm ?? 70);
            const Lsr = Number(s.shin_len_rear_mm ?? 90);
            const kabF = Math.max(0, Math.min(Ltf, Number(s.front_knee_attach_backoff_mm ?? 0)));
            const kabR = Math.max(0, Math.min(Ltr, Number(s.rear_knee_attach_backoff_mm ?? 0)));

            const r_ft = Number(s.front_thigh_radius_mm ?? 6);
            const r_fs = Number(s.front_shin_radius_mm ?? 6);
            const r_rt = Number(s.rear_thigh_radius_mm ?? 6);
            const r_rs = Number(s.rear_shin_radius_mm ?? 6);

            const off_fh = Number(s.front_hip_offset_deg ?? 0);
            const off_fk = Number(s.front_knee_offset_deg ?? 0);
            const off_rh = Number(s.rear_hip_offset_deg ?? 0);
            const off_rk = Number(s.rear_knee_offset_deg ?? 0);

            // anchors in model space (mm)
            // Mirror by side so left frame shows front left of rear,
            // right frame shows front right of rear.
            const Hf = { x: 0, y: hip_y };
            const Hr = { x: (side === "left" ? hip_dx : -hip_dx), y: hip_y };

            const hipLine = (side === "left") ? { x: 1, y: 0 } : { x: -1, y: 0 };

            let out_fh = Number(j.front_hip.measured);
            if (j.front_hip.mode === "hip_line_relative_deg") {
                const rel = normalizeDeg(Number(j.front_hip.measured) + off_fh);
                out_fh = normalizeDeg(angleFromHipUnit(rotateCcwDeg(hipLine, rel)) - off_fh);
            }

            let out_rh = Number(j.rear_hip.measured);
            if (j.rear_hip.mode === "hip_line_relative_deg") {
                const rel = normalizeDeg(Number(j.rear_hip.measured) + off_rh);
                out_rh = normalizeDeg(angleFromHipUnit(rotateCcwDeg(hipLine, rel)) - off_rh);
            }

            const a_fh = normalizeDeg(out_fh + off_fh);
            const a_rh = normalizeDeg(out_rh + off_rh);
            const uf = unitFromAngleDeg(a_fh);
            const ur = unitFromAngleDeg(a_rh);

            let out_fk = Number(j.front_knee.measured);
            if (j.front_knee.mode === "knee_relative_deg") {
                const rel = normalizeDeg(Number(j.front_knee.measured) + off_fk);
                const ba = { x: -uf.x, y: -uf.y }; // knee->hip
                const vWorld = rotateCcwDeg(ba, rel);
                const vLocal = rotateCcwDeg(vWorld, -a_fh);
                const absFk = angleFromKneeLocalUnit(vLocal);
                out_fk = normalizeDeg(absFk - off_fk);
            }

            let out_rk = Number(j.rear_knee.measured);
            if (j.rear_knee.mode === "knee_relative_deg") {
                const rel = normalizeDeg(Number(j.rear_knee.measured) + off_rk);
                const ba = { x: -ur.x, y: -ur.y }; // knee->hip
                const vWorld = rotateCcwDeg(ba, rel);
                const vLocal = rotateCcwDeg(vWorld, -a_rh);
                const absRk = angleFromKneeLocalUnit(vLocal);
                out_rk = normalizeDeg(absRk - off_rk);
            }

            const a_fk = normalizeDeg(out_fk + off_fk);
            const a_rk = normalizeDeg(out_rk + off_rk);
            const KfTip = add(Hf, mul(uf, Ltf));
            const Kf = add(Hf, mul(uf, Ltf - kabF));
            const vf = rotateCcwDeg(unitFromKneeAngleDeg(a_fk), a_fh);
            const Ff = add(Kf, mul(vf, Lsf));

            const KrTip = add(Hr, mul(ur, Ltr));
            const Kr = add(Hr, mul(ur, Ltr - kabR));
            const vr = rotateCcwDeg(unitFromKneeAngleDeg(a_rk), a_rh);
            const Fr = add(Kr, mul(vr, Lsr));

            const frontRelDeg = segmentRelativeDeg(Hf, Kf, Ff);
            const rearRelDeg = segmentRelativeDeg(Hr, Kr, Fr);
            const hipVsFrontThighDeg = angleBetweenSegmentsDeg(Hf, Hr, Hf, KfTip);
            const hipVsRearThighDeg = angleBetweenSegmentsDeg(Hf, Hr, Hr, KrTip);

            return {
                side,
                anchors: { Hf, Hr, Kf, Kr, KfTip, KrTip, Ff, Fr },
                angles: {
                    a_fh: Number(j.front_hip.physical),
                    a_fk: Number(j.front_knee.physical),
                    a_rh: Number(j.rear_hip.physical),
                    a_rk: Number(j.rear_knee.physical),
                },
                simAngles: { a_fh, a_fk, a_rh, a_rk },
                relative: { front_deg: frontRelDeg, rear_deg: rearRelDeg },
                baselines: {
                    hip_vs_front_thigh_deg: hipVsFrontThighDeg,
                    hip_vs_rear_thigh_deg: hipVsRearThighDeg,
                },
                lengths: { hip_dx, hip_y, Ltf, Lsf, Ltr, Lsr, kabF, kabR },
                radii: { r_ft, r_fs, r_rt, r_rs },
            };
        }

        function setGeoReadout(id, v) {
            const el = document.getElementById(id);
            if (!el) return;
            if (!Number.isFinite(v)) {
                el.value = "—";
                return;
            }
            el.value = `${v.toFixed(1)} deg`;
        }

        function renderViz() {
            const canvas = document.getElementById("viz");
            const ctx = canvas.getContext("2d");
            const resized = resizeCanvasToDisplaySize(canvas);
            if (resized) { /* noop */ }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const g = buildVizGeometry();
            const overlay = document.getElementById("vizOverlay");
            const poseInfo = document.getElementById("poseInfo");

            if (!g) {
                overlay.textContent = "Waiting for dynamic_limits…";
                poseInfo.textContent = "—";
                setGeoReadout("geoHipFront", NaN);
                setGeoReadout("geoHipRear", NaN);
                setGeoReadout("geoRelFront", NaN);
                setGeoReadout("geoRelRear", NaN);
                return;
            }

            const { Hf, Hr, Kf, Kr, KfTip, KrTip, Ff, Fr } = g.anchors;

            // Compute bounds in model space
            const pts = [Hf, Hr, Kf, Kr, KfTip, KrTip, Ff, Fr];
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const p of pts) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            }

            // pad bounds
            const pad = 50;
            minX -= pad; maxX += pad;
            minY = Math.min(minY - pad, -20);
            maxY += pad;

            // Map model -> canvas
            const W = canvas.width, H = canvas.height;
            const sx = W / (maxX - minX);
            const sy = H / (maxY - minY);
            const s = Math.min(sx, sy);

            const ox = (W - s * (maxX - minX)) / 2 - s * minX;
            const oy = (H - s * (maxY - minY)) / 2 + s * maxY;

            const toCanvas = (p) => ({ x: ox + s * p.x, y: oy - s * p.y });

            // Ground line y=0
            const y0 = toCanvas({ x: 0, y: 0 }).y;
            ctx.save();
            ctx.globalAlpha = 0.35;
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, y0);
            ctx.lineTo(W, y0);
            ctx.stroke();
            ctx.restore();

            function drawGuideLine(a, b, color, label) {
                const A = toCanvas(a);
                const B = toCanvas(b);
                ctx.save();
                ctx.globalAlpha = 0.95;
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 7]);
                ctx.beginPath();
                ctx.moveTo(A.x, A.y);
                ctx.lineTo(B.x, B.y);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = color;
                ctx.font = `${Math.max(12, 12 * (window.devicePixelRatio || 1))}px system-ui`;
                const mx = (A.x + B.x) * 0.5;
                const my = (A.y + B.y) * 0.5;
                ctx.fillText(label, mx + 8, my - 8);
                ctx.restore();
            }

            // Draw capsule helper (thick line with round caps)
            function drawCapsule(a, b, r_mm, alpha) {
                const A = toCanvas(a);
                const B = toCanvas(b);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = "#ffffff";
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.lineWidth = Math.max(1, 2 * r_mm * s);
                ctx.beginPath();
                ctx.moveTo(A.x, A.y);
                ctx.lineTo(B.x, B.y);
                ctx.stroke();
                ctx.restore();
            }

            function drawLink(a, b, w, alpha) {
                const A = toCanvas(a);
                const B = toCanvas(b);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = "#ffffff";
                ctx.lineWidth = w;
                ctx.beginPath();
                ctx.moveTo(A.x, A.y);
                ctx.lineTo(B.x, B.y);
                ctx.stroke();
                ctx.restore();
            }

            function drawJoint(p, alpha) {
                const P = toCanvas(p);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = "#ffffff";
                ctx.beginPath();
                ctx.arc(P.x, P.y, Math.max(3, 5 * (window.devicePixelRatio || 1)), 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // capsules (semi transparent)
            drawCapsule(Hf, KfTip, g.radii.r_ft, 0.18);
            drawCapsule(Kf, Ff, g.radii.r_fs, 0.18);
            drawCapsule(Hr, KrTip, g.radii.r_rt, 0.18);
            drawCapsule(Kr, Fr, g.radii.r_rs, 0.18);

            // centerlines (more visible)
            drawLink(Hf, KfTip, 3, 0.55);
            drawLink(Kf, Ff, 3, 0.55);
            drawLink(Hr, KrTip, 3, 0.55);
            drawLink(Kr, Fr, 3, 0.55);

            // highlighted guide lines for alignment checks
            drawGuideLine(Hf, Hr, "#57d4ff", "Hip line");

            // joints
            drawJoint(Hf, 0.9);
            drawJoint(Kf, 0.8);
            drawJoint(Hr, 0.9);
            drawJoint(Kr, 0.8);

            // labels
            ctx.save();
            ctx.fillStyle = "#ffffff";
            ctx.globalAlpha = 0.7;
            ctx.font = `${Math.max(12, 12 * (window.devicePixelRatio || 1))}px system-ui`;
            const HfC = toCanvas(Hf);
            const HrC = toCanvas(Hr);
            ctx.fillText("Front hip", HfC.x + 8, HfC.y - 8);
            ctx.fillText("Rear hip", HrC.x + 8, HrC.y - 8);
            ctx.restore();

            // pose info
            poseInfo.textContent =
                `${g.side.toUpperCase()} | mode=${mode.toUpperCase()} | ` +
                `FH=${Math.round(g.angles.a_fh)} FK=${Math.round(g.angles.a_fk)} ` +
                `RH=${Math.round(g.angles.a_rh)} RK=${Math.round(g.angles.a_rk)}`;

            const sideStatus = collisionStatus?.[mode]?.[g.side] || null;
            let collisionTxt = "Collision: unknown";
            if (sideStatus) {
                const details = sideStatus.details || {};
                const pair = details.pair || "?";
                const d = Number(details.min_distance_mm);
                const t = Number(details.threshold_mm);
                const dTxt = Number.isFinite(d) ? d.toFixed(2) : "?";
                const tTxt = Number.isFinite(t) ? t.toFixed(2) : "?";
                collisionTxt = sideStatus.collides
                    ? `Collision: YES (${pair}, d=${dTxt} <= ${tTxt})`
                    : `Collision: no (${pair}, d=${dTxt} > ${tTxt})`;
            }

            overlay.textContent =
                `Hip dx=${g.lengths.hip_dx.toFixed(1)}mm, hip y=${g.lengths.hip_y.toFixed(1)}mm • ` +
                `Knee backoff: F=${g.lengths.kabF.toFixed(1)} R=${g.lengths.kabR.toFixed(1)}mm • ` +
                `Offsets: FH=${(dynVars[g.side].front_hip_offset_deg ?? 0).toFixed(1)} FK=${(dynVars[g.side].front_knee_offset_deg ?? 0).toFixed(1)} ` +
                `RH=${(dynVars[g.side].rear_hip_offset_deg ?? 0).toFixed(1)} RK=${(dynVars[g.side].rear_knee_offset_deg ?? 0).toFixed(1)} • ` +
                collisionTxt;

            setGeoReadout("geoHipFront", g.baselines.hip_vs_front_thigh_deg);
            setGeoReadout("geoHipRear", g.baselines.hip_vs_rear_thigh_deg);
            setGeoReadout("geoRelFront", g.relative.front_deg);
            setGeoReadout("geoRelRear", g.relative.rear_deg);

        }

        /* -------------------- Refresh (config) -------------------- */
        async function refreshAnglesOnly() {
            const resp = await api("/api/config");
            if (!resp.ok) return;
            hwAngles = resp.data.hw_angles || hwAngles;
            simAngles = resp.data.sim_angles || simAngles;
            dynVars = resp.data.dynamic_limits || dynVars;
            collisionStatus = resp.data.collision_status || collisionStatus;
            renderViz();
        }

        async function refresh() {
            const resp = await api("/api/config");
            if (!resp.ok) {
                alert("Failed to load config");
                return;
            }

            locations = resp.data.locations;
            draft = resp.data.draft;
            availableChannels = resp.data.available_channels;
            dynVars = resp.data.dynamic_limits;
            hwAngles = resp.data.hw_angles || {};
            simAngles = resp.data.sim_angles || {};
            collisionStatus = resp.data.collision_status || null;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);

            const hw = document.getElementById("hw-status");
            if (resp.data.hardware_available) {
                hw.innerHTML = `Hardware: <b>available</b>`;
            } else {
                const msg = resp.data.hardware_error ? ` (${resp.data.hardware_error})` : "";
                hw.innerHTML = `Hardware: <span class="danger"><b>unavailable</b></span>${msg}`;
            }

            // side radios from dyn vars
            if (dynVars) {
                setSideRadio(activeSide());
                dlLastSentStr = JSON.stringify({ dynamic_limits: dynVars });
                syncDynVarsInputs();
                setDlStatus("Loaded", "muted");
            }

            await loadStances();

            renderControlBar();
            renderServoButtons();
            buildChannelSelectOptions();
            syncSelectedSidebar();

            // restore angle input based on current mode
            if (selectedLocation) {
                applySelection(selectedLocation);
            }

            setModeRadios();
            renderViz();
        }

        /* -------------------- Events -------------------- */

        // Save / Reset
        document.getElementById("saveBtn").addEventListener("click", async () => {
            const resp = await api("/api/save", "POST", {});
            if (!resp.ok) {
                alert(resp.data.error || "Save failed");
                return;
            }
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
        });

        document.getElementById("resetBtn").addEventListener("click", async () => {
            const resp = await api("/api/reset", "POST", {});
            if (!resp.ok) {
                alert(resp.data.error || "Reset failed");
                return;
            }
            draft = resp.data.draft;
            availableChannels = resp.data.available_channels;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
            buildChannelSelectOptions();
            syncSelectedSidebar();
        });

        // Servo buttons
        for (const [btnId, locKey] of Object.entries(BUTTON_TO_LOCATION)) {
            const btn = document.getElementById(btnId);
            btn.addEventListener("click", () => applySelection(locKey));
        }

        // Channel dropdown (selected servo only)
        document.getElementById("channelSelect").addEventListener("change", async (e) => {
            if (!selectedLocation) return;
            const v = e.target.value;
            const ch = v === "" ? null : parseInt(v, 10);

            const resp = await api("/api/channel", "POST", { location: selectedLocation, channel: ch });
            if (!resp.ok) {
                alert(resp.data.error || "Failed to set channel");
                buildChannelSelectOptions(); // revert UI
                return;
            }
            draft = resp.data.draft;
            availableChannels = resp.data.available_channels;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
            buildChannelSelectOptions();
        });

        // Limits editing hooks
        document.getElementById("minDeg").addEventListener("change", pushLimits);
        document.getElementById("maxDeg").addEventListener("change", pushLimits);
        document.getElementById("invertChk").addEventListener("change", pushLimits);

        // Angle input UX: auto-select on focus/click
        const angleInput = document.getElementById("angleInput");
        angleInput.addEventListener("focus", () => angleInput.select());
        angleInput.addEventListener("click", () => angleInput.select());
        angleInput.addEventListener("keydown", async (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                document.getElementById("sendBtn").click();
            }
        });

        // Send button
        document.getElementById("sendBtn").addEventListener("click", async () => {
            if (!selectedLocation) {
                alert("Select a servo first.");
                return;
            }
            const parsed = getAngleFromInput();
            if (!parsed.ok) {
                alert(parsed.error);
                return;
            }
            const angle = parsed.value;
            setAngleInput(angle);
            await sendAngle(angle);
        });

        document.getElementById("activateStanceBtn").addEventListener("click", async () => {
            await activateStance();
        });

        // Notes field: debounce save
        const notesArea = document.getElementById("notesArea");
        notesArea.addEventListener("input", scheduleNotesSave);

        // Mode radios
        document.getElementById("modeNormal").addEventListener("change", () => {
            if (!document.getElementById("modeNormal").checked) return;
            mode = "normal";
            saveMode();
            restoreUiToActualStateAfterModeSwitch();
            setCmdStatus("Mode: Normal", "muted");
        });
        document.getElementById("modeTest").addEventListener("change", () => {
            if (!document.getElementById("modeTest").checked) return;
            mode = "test";
            saveMode();
            restoreUiToActualStateAfterModeSwitch();
            setCmdStatus("Mode: Test (no PWM; sim state walks)", "muted");
        });

        // Side radios
        document.getElementById("sideLeft").addEventListener("change", () => {
            if (!document.getElementById("sideLeft").checked) return;
            if (!dynVars) return;
            dynVars.active_side = "left";
            syncDynVarsInputs();
            scheduleDynVarsSave();
            renderViz();
        });

        document.getElementById("sideRight").addEventListener("change", () => {
            if (!document.getElementById("sideRight").checked) return;
            if (!dynVars) return;
            dynVars.active_side = "right";
            syncDynVarsInputs();
            scheduleDynVarsSave();
            renderViz();
        });

        // Dynamic vars inputs change handlers (debounced save)
        [
            "dl_step", "dl_iters",
            "dl_hip_dx", "dl_hip_y",
            "dl_ltf", "dl_lsf", "dl_ltr", "dl_lsr", "dl_kab_f", "dl_kab_r",
            "dl_r_ft", "dl_r_fs", "dl_r_rt", "dl_r_rs",
            "dl_off_fh", "dl_off_fk", "dl_off_rh", "dl_off_rk",
        ].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener("input", () => {
                scheduleDynVarsSave();
            });
            el.addEventListener("change", () => {
                scheduleDynVarsSave();
            });
        });

        // Calibration controls
        document.getElementById("cal_profile_select").addEventListener("change", () => {
            renderCalibrationUi();
        });
        document.getElementById("cal_mode_select").addEventListener("change", () => {
            if (!dynVars) return;
            ensureCalibrationModel();
            const name = selectedCalibrationProfileName();
            dynVars.calibration_profiles[name].measurement_mode = document.getElementById("cal_mode_select").value;
            renderCalibrationUi();
            scheduleDynVarsSave();
            renderViz();
        });
        document.getElementById("cal_create_profile_btn").addEventListener("click", () => {
            if (!dynVars) return;
            ensureCalibrationModel();
            const raw = String(document.getElementById("cal_new_profile").value || "").trim();
            if (!/^[A-Za-z0-9_-]{1,40}$/.test(raw)) {
                setDlStatus("Profile name must match [A-Za-z0-9_-]{1,40}", "danger");
                return;
            }
            if (!dynVars.calibration_profiles[raw]) {
                dynVars.calibration_profiles[raw] = {
                    fit_mode: "linear_best_fit",
                    measurement_mode: "servo_physical_deg",
                    pairs: [],
                };
            }
            document.getElementById("cal_new_profile").value = "";
            renderCalibrationUi();
            document.getElementById("cal_profile_select").value = raw;
            scheduleDynVarsSave();
        });
        document.getElementById("cal_delete_profile_btn").addEventListener("click", () => {
            if (!dynVars) return;
            ensureCalibrationModel();
            const name = selectedCalibrationProfileName();
            if (name === "identity") {
                setDlStatus("Cannot delete identity profile", "danger");
                return;
            }
            delete dynVars.calibration_profiles[name];
            for (const loc of locations) {
                if (dynVars.joint_calibration_map[loc.key] === name) {
                    dynVars.joint_calibration_map[loc.key] = "identity";
                }
            }
            renderCalibrationUi();
            scheduleDynVarsSave();
            renderViz();
        });
        document.getElementById("cal_add_pair_btn").addEventListener("click", () => {
            if (!dynVars) return;
            ensureCalibrationModel();
            const name = selectedCalibrationProfileName();
            const cmd = toFloat(document.getElementById("cal_cmd_input").value, null);
            const act = toFloat(document.getElementById("cal_actual_input").value, null);
            if (cmd === null || act === null) {
                setDlStatus("Calibration pair requires numeric commanded/actual", "danger");
                return;
            }
            const c = Math.max(0, Math.min(270, cmd));
            const a = Math.max(0, Math.min(270, act));
            const prof = dynVars.calibration_profiles[name] || { fit_mode: "linear_best_fit", pairs: [] };
            if (!Array.isArray(prof.pairs)) prof.pairs = [];
            prof.pairs.push({ commanded_deg: c, actual_deg: a });
            dynVars.calibration_profiles[name] = prof;
            renderCalibrationUi();
            scheduleDynVarsSave();
            renderViz();
        });

        // Canvas resize redraw
        window.addEventListener("resize", () => renderViz());

        /* -------------------- Init -------------------- */
        function initModeRadios() {
            setModeRadios();
            setCmdStatus(mode === "test" ? "Mode: Test (no PWM; sim state walks)" : "Mode: Normal", "muted");
        }

        loadLastAngles();
        loadHotkeys();
        loadMode();
        initCollapsibleSections();
        attachSelectOverwrite([
            "dl_step", "dl_iters",
            "dl_hip_dx", "dl_hip_y",
            "dl_ltf", "dl_lsf", "dl_ltr", "dl_lsr", "dl_kab_f", "dl_kab_r",
            "dl_r_ft", "dl_r_fs", "dl_r_rt", "dl_r_rs",
            "dl_off_fh", "dl_off_fk", "dl_off_rh", "dl_off_rk",
            "cal_cmd_input", "cal_actual_input",
        ]);
        syncHotkeyInputs();
        attachHotkeyInputHandlers();
        initModeRadios();
        setAngleInput(0);

        refresh();
        loadNotes();
    </script>
</body>

</html>
