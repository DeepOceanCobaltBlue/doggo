<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Doggo Config</title>
    <style>
        :root {
            --bg: #0f1220;
            --panel: #181c2f;
            --accent: #4da3ff;
            --text: #e6e8f0;
            --muted: #9aa0b3;
            --selected: #263a5f;
            --danger: #ff5d5d;
            --ok: #4cff91;
            --card: #0f1220;
            --border: rgba(255, 255, 255, .14);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
            background: var(--bg);
            color: var(--text);
        }

        .wrap {
            display: grid;
            grid-template-columns: 1fr 360px;
            grid-template-rows: 1fr 180px;
            height: 100vh;
            gap: 12px;
            padding: 12px;
        }

        .main {
            background: var(--panel);
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .sidebar {
            background: var(--panel);
            border-radius: 16px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: auto;
        }

        .bar {
            grid-column: 1 / span 2;
            background: var(--panel);
            border-radius: 16px;
            padding: 12px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            overflow: hidden;
        }

        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 12px;
            height: 100%;
        }

        .title {
            font-weight: 900;
            font-size: 18px;
            margin: 0 0 4px 0;
        }

        .muted {
            color: var(--muted);
            font-size: 13px;
        }

        .divider {
            height: 1px;
            background: rgba(255, 255, 255, .10);
            margin: 8px 0;
        }

        button {
            background: transparent;
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 12px;
            padding: 10px 12px;
            cursor: pointer;
            user-select: none;
        }

        button.primary {
            border-color: var(--accent);
            color: var(--accent);
        }

        button.selected {
            outline: 2px solid var(--accent);
            background: rgba(38, 58, 95, .55);
        }

        button:disabled {
            opacity: .35;
            cursor: not-allowed;
        }

        .danger {
            color: var(--danger);
        }

        .ok {
            color: var(--ok);
        }

        input[type="number"],
        input[type="text"],
        select {
            width: 100%;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: #0f1220;
            color: var(--text);
        }

        input[type="checkbox"] {
            transform: scale(1.1);
        }

        textarea {
            width: 100%;
            min-height: 130px;
            resize: vertical;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: #0f1220;
            color: var(--text);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            line-height: 1.35;
        }

        .row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Main dynamic limits placeholder */
        .mainHeader {
            padding: 12px 14px;
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, .10);
        }

        .mainBody {
            padding: 14px;
            overflow: auto;
            flex: 1;
        }

        .placeholder {
            border: 1px dashed rgba(255, 255, 255, .22);
            border-radius: 14px;
            padding: 14px;
            min-height: 220px;
            background: rgba(15, 18, 32, .55);
        }

        /* Bottom bar left: servo selector grid */
        .selectorWrap {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
        }

        .selectorTopLabels {
            display: grid;
            grid-template-columns: 1fr 1fr 160px 1fr 1fr;
            gap: 10px;
            align-items: center;
            justify-items: center;
            padding: 0 2px;
        }

        .selectorTopLabels .lr {
            font-weight: 800;
            color: var(--muted);
            font-size: 12px;
            letter-spacing: .6px;
            text-transform: uppercase;
        }

        .selectorGridArea {
            display: grid;
            grid-template-columns: 64px 1fr 1fr 160px 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 10px;
            align-items: center;
        }

        .rowLabel {
            font-weight: 900;
            color: var(--muted);
            font-size: 12px;
            letter-spacing: .6px;
            text-transform: uppercase;
            text-align: right;
            padding-right: 4px;
        }

        .servoBtn {
            width: 100%;
            font-weight: 800;
            text-transform: lowercase;
        }

        .channelBlock {
            grid-column: 4;
            grid-row: 1 / span 2;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-self: stretch;
            justify-content: center;
        }

        .channelBlock label {
            font-size: 12px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: .6px;
            font-weight: 800;
            text-align: center;
        }

        /* Bottom bar right: angle control */
        .angleWrap {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
        }

        .angleRow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .steps {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .angleBox {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, .14);
            border-radius: 14px;
            background: #0f1220;
        }

        .angleBox input {
            width: 110px;
            text-align: center;
            font-size: 18px;
            font-weight: 900;
            padding: 10px 10px;
        }

        .hotkeys {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .tiny {
            font-size: 12px;
            padding: 8px 10px;
            border-radius: 10px;
            min-width: 70px;
        }

        /* Sidebar split */
        .sidebarSection {
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 14px;
            padding: 12px;
            background: rgba(15, 18, 32, .40);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sectionTitle {
            font-weight: 900;
            font-size: 14px;
            margin-bottom: 2px;
        }
    </style>
</head>

<body>
    <div class="wrap">

        <div class="main">
            <div class="mainHeader">
                <div>
                    <div class="title">Dynamic Limits</div>
                    <div class="muted">Placeholder area for collision-aware limits (front/rear interference) editor.
                    </div>
                </div>
                <div id="hw-status" class="muted"></div>
            </div>

            <div class="mainBody">
                <div class="placeholder">
                    <div style="font-weight:900;margin-bottom:6px;">Dynamic limits table (coming next)</div>
                    <div class="muted">
                        This area will define relative constraints between front/rear legs on the same side to prevent
                        collisions.
                        We’ll build the editor and then enforce it in the command path.
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="row" style="align-items:flex-start;">
                <div>
                    <div class="title" style="margin:0;">Doggo Config</div>
                    <div class="muted">Channel mapping + travel limits + notes/hotkeys.</div>
                </div>
            </div>

            <div class="row">
                <button id="saveBtn" class="primary" disabled>Save</button>
                <button id="resetBtn" disabled>Reset</button>
            </div>

            <div class="sidebarSection">
                <div class="sectionTitle">Travel limits</div>
                <div class="muted">Selected: <span id="selectedLabel">None</span></div>

                <div class="field">
                    <label class="muted">Min angle (deg)</label>
                    <input id="minDeg" type="number" min="0" max="270" step="1" disabled />
                </div>

                <div class="field">
                    <label class="muted">Max angle (deg)</label>
                    <input id="maxDeg" type="number" min="0" max="270" step="1" disabled />
                </div>

                <div class="row">
                    <label class="muted" for="invertChk">Invert</label>
                    <input id="invertChk" type="checkbox" disabled />
                </div>
            </div>

            <div class="sidebarSection">
                <div class="sectionTitle">Universal settings</div>

                <div>
                    <div style="font-weight:900; margin-bottom:6px;">Hotkeys (programmable)</div>
                    <div class="muted" style="margin-bottom:8px;">Edit values here; buttons are on the bottom-right.
                    </div>
                    <div class="field" style="gap:10px;">
                        <input id="hk0" type="number" min="0" max="270" step="1" />
                        <input id="hk1" type="number" min="0" max="270" step="1" />
                        <input id="hk2" type="number" min="0" max="270" step="1" />
                        <input id="hk3" type="number" min="0" max="270" step="1" />
                        <input id="hk4" type="number" min="0" max="270" step="1" />
                        <input id="hk5" type="number" min="0" max="270" step="1" />
                    </div>
                </div>

                <div class="divider"></div>

                <div>
                    <div style="font-weight:900; margin-bottom:6px;">Notes</div>
                    <textarea id="notesArea"
                        placeholder="Saved to config/channel_notes.json (not part of config_file.json)."></textarea>
                    <div id="notesStatus" class="muted" style="margin-top:6px;">—</div>
                </div>
            </div>

            <div class="muted">
                Limits apply when you send commands in this app and will be saved to
                <code>config/config_file.json</code>.
            </div>
        </div>

        <div class="bar">

            <!-- Left half: servo selection + channel dropdown in middle gap -->
            <div class="card selectorWrap">
                <div class="row">
                    <div style="font-weight:900;">Servo select</div>
                    <div class="muted" id="selectedShort">None</div>
                </div>

                <div class="selectorTopLabels">
                    <div class="lr" style="grid-column:1 / span 2;">Left</div>
                    <div></div>
                    <div class="lr" style="grid-column:4 / span 2;">Right</div>
                </div>

                <div class="selectorGridArea">
                    <!-- Front row label -->
                    <div class="rowLabel" style="grid-row:1;">Front</div>

                    <button id="btn_front_left_knee" class="servoBtn" style="grid-row:1;grid-column:2;">knee</button>
                    <button id="btn_front_left_hip" class="servoBtn" style="grid-row:1;grid-column:3;">hip</button>

                    <div class="channelBlock">
                        <label>channel</label>
                        <select id="channelSelect"></select>
                    </div>

                    <button id="btn_front_right_hip" class="servoBtn" style="grid-row:1;grid-column:5;">hip</button>
                    <button id="btn_front_right_knee" class="servoBtn" style="grid-row:1;grid-column:6;">knee</button>

                    <!-- Rear row label -->
                    <div class="rowLabel" style="grid-row:2;">Rear</div>

                    <button id="btn_back_left_knee" class="servoBtn" style="grid-row:2;grid-column:2;">knee</button>
                    <button id="btn_back_left_hip" class="servoBtn" style="grid-row:2;grid-column:3;">hip</button>

                    <button id="btn_back_right_hip" class="servoBtn" style="grid-row:2;grid-column:5;">hip</button>
                    <button id="btn_back_right_knee" class="servoBtn" style="grid-row:2;grid-column:6;">knee</button>
                </div>

                <div class="muted">
                    Select a servo, then assign its PCA channel using the dropdown.
                </div>
            </div>

            <!-- Right half: angle control -->
            <div class="card angleWrap">
                <div class="row">
                    <div style="font-weight:900;">Angle control</div>
                    <div class="muted">0–270</div>
                </div>

                <div class="angleRow">
                    <div class="steps" id="negSteps"></div>

                    <div class="angleBox">
                        <input id="angleInput" type="text" inputmode="numeric" value="0" />
                        <button id="sendBtn" class="primary">Send</button>
                    </div>

                    <div class="steps" id="posSteps"></div>
                </div>

                <div class="hotkeys" id="hotkeyButtons"></div>
            </div>

        </div>
    </div>

    <script>
        /* -------------------- State -------------------- */
        let locations = [];
        let draft = null;
        let availableChannels = [];
        let selectedLocation = null;

        // Per-location last commanded angle (persisted)
        const LAST_ANGLES_KEY = "doggo:lastAngles:v1";
        let lastAngles = {};

        // Hotkeys (persisted)
        const HOTKEYS_KEY = "doggo:hotkeys:v1";
        let hotkeys = [0, 70, 135, 200, 250, 270];

        let currentAngle = 0;
        const steps = [1, 5, 10];

        // Button mapping (per your specified order)
        const BUTTON_TO_LOCATION = {
            btn_front_left_knee: "front_left_knee",
            btn_front_left_hip: "front_left_hip",
            btn_front_right_hip: "front_right_hip",
            btn_front_right_knee: "front_right_knee",

            btn_back_left_knee: "back_left_knee",
            btn_back_left_hip: "back_left_hip",
            btn_back_right_hip: "back_right_hip",
            btn_back_right_knee: "back_right_knee",
        };

        /* -------------------- API helpers -------------------- */
        async function api(url, method = "GET", body = null) {
            const opts = { method, headers: {} };
            if (body) {
                opts.headers["Content-Type"] = "application/json";
                opts.body = JSON.stringify(body);
            }
            const res = await fetch(url, opts);
            const data = await res.json();
            return { ok: res.ok, status: res.status, data };
        }

        /* -------------------- Persistence -------------------- */
        function loadLastAngles() {
            try {
                const s = localStorage.getItem(LAST_ANGLES_KEY);
                lastAngles = s ? JSON.parse(s) : {};
                if (typeof lastAngles !== "object" || lastAngles === null) lastAngles = {};
            } catch {
                lastAngles = {};
            }
        }

        function saveLastAngles() {
            try { localStorage.setItem(LAST_ANGLES_KEY, JSON.stringify(lastAngles)); } catch { }
        }

        function loadHotkeys() {
            try {
                const s = localStorage.getItem(HOTKEYS_KEY);
                const arr = s ? JSON.parse(s) : null;
                if (Array.isArray(arr) && arr.length === 6) {
                    hotkeys = arr.map(v => clampInt(toInt(v, 0), 0, 270));
                }
            } catch { }
        }

        function saveHotkeys() {
            try { localStorage.setItem(HOTKEYS_KEY, JSON.stringify(hotkeys)); } catch { }
        }

        /* -------------------- Utils -------------------- */
        function clampInt(v, lo, hi) {
            return Math.max(lo, Math.min(hi, v));
        }

        function toInt(v, fallback = null) {
            const n = Number.parseInt(String(v).trim(), 10);
            return Number.isFinite(n) ? n : fallback;
        }

        function isStrictIntegerString(s) {
            return /^[0-9]+$/.test(s);
        }

        function setAngleInput(v) {
            const el = document.getElementById("angleInput");
            el.value = String(v);
            currentAngle = v;
        }

        function getAngleFromInput() {
            const el = document.getElementById("angleInput");
            const raw = String(el.value ?? "").trim();
            if (!isStrictIntegerString(raw)) return { ok: false, error: "Angle must be digits only (0..270)." };
            const n = toInt(raw, null);
            if (n === null) return { ok: false, error: "Angle must be an integer." };
            if (n < 0 || n > 270) return { ok: false, error: "Angle out of range (0..270)." };
            return { ok: true, value: n };
        }

        function locLabel(locKey) {
            const loc = locations.find(l => l.key === locKey);
            return loc ? loc.label : locKey;
        }

        /* -------------------- Sidebar + selection -------------------- */
        function setSaveResetEnabled(saveEnabled, resetEnabled) {
            document.getElementById("saveBtn").disabled = !saveEnabled;
            document.getElementById("resetBtn").disabled = !resetEnabled;
        }

        function syncSelectedSidebar() {
            const labelEl = document.getElementById("selectedLabel");
            const shortEl = document.getElementById("selectedShort");
            const minEl = document.getElementById("minDeg");
            const maxEl = document.getElementById("maxDeg");
            const invEl = document.getElementById("invertChk");

            if (!selectedLocation) {
                labelEl.textContent = "None";
                shortEl.textContent = "None";
                minEl.value = "";
                maxEl.value = "";
                invEl.checked = false;
                minEl.disabled = true;
                maxEl.disabled = true;
                invEl.disabled = true;
                return;
            }

            labelEl.textContent = locLabel(selectedLocation);
            shortEl.textContent = locLabel(selectedLocation);

            const lim = draft.locations[selectedLocation].limits;
            minEl.value = String(lim.deg_min);
            maxEl.value = String(lim.deg_max);
            invEl.checked = !!lim.invert;

            minEl.disabled = false;
            maxEl.disabled = false;
            invEl.disabled = false;
        }

        function renderServoButtons() {
            for (const [btnId, locKey] of Object.entries(BUTTON_TO_LOCATION)) {
                const btn = document.getElementById(btnId);
                if (!btn) continue;
                btn.classList.toggle("selected", selectedLocation === locKey);
            }
        }

        function buildChannelSelectOptions() {
            const sel = document.getElementById("channelSelect");
            sel.innerHTML = "";

            // Unassigned option
            const optNone = document.createElement("option");
            optNone.value = "";
            optNone.textContent = "— Unassigned —";
            sel.appendChild(optNone);

            if (!selectedLocation || !draft) {
                sel.value = "";
                sel.disabled = true;
                return;
            }

            sel.disabled = false;

            const current = draft.locations[selectedLocation].channel; // may be null
            const pool = [...availableChannels];

            if (current !== null && current !== undefined && !pool.includes(current)) pool.push(current);
            pool.sort((a, b) => a - b);

            pool.forEach(ch => {
                const o = document.createElement("option");
                o.value = String(ch);
                o.textContent = `Channel ${ch}`;
                sel.appendChild(o);
            });

            sel.value = (current === null || current === undefined) ? "" : String(current);
        }

        function applySelection(locKey) {
            selectedLocation = locKey;
            syncSelectedSidebar();
            renderServoButtons();
            buildChannelSelectOptions();

            // per-location last commanded angle
            if (lastAngles[selectedLocation] !== undefined) {
                const v = clampInt(toInt(lastAngles[selectedLocation], 0), 0, 270);
                setAngleInput(v);
            }
        }

        /* -------------------- Limits API -------------------- */
        async function pushLimits() {
            if (!selectedLocation) return;

            const minEl = document.getElementById("minDeg");
            const maxEl = document.getElementById("maxDeg");
            const invEl = document.getElementById("invertChk");

            const deg_min = parseInt(minEl.value, 10);
            const deg_max = parseInt(maxEl.value, 10);
            const invert = !!invEl.checked;

            const resp = await api("/api/limits", "POST", { location: selectedLocation, deg_min, deg_max, invert });
            if (!resp.ok) {
                alert(resp.data.error || "Failed to set limits");
                return;
            }
            draft = resp.data.draft;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
            syncSelectedSidebar();
        }

        /* -------------------- Command path -------------------- */
        async function sendAngle(angle) {
            if (!selectedLocation) {
                alert("Select a servo first.");
                return;
            }
            const resp = await api("/api/command", "POST", { location: selectedLocation, angle_deg: angle });
            if (!resp.ok) {
                alert(resp.data.error || "Command failed");
                return;
            }
            lastAngles[selectedLocation] = angle;
            saveLastAngles();
        }

        async function adjustAngle(delta) {
            if (!selectedLocation) {
                alert("Select a servo first.");
                return;
            }
            const next = clampInt(currentAngle + delta, 0, 270);
            setAngleInput(next);
            await sendAngle(next);
        }

        /* -------------------- Angle control rendering -------------------- */
        function renderControlBar() {
            const neg = document.getElementById("negSteps");
            const pos = document.getElementById("posSteps");
            neg.innerHTML = "";
            pos.innerHTML = "";

            steps.slice().reverse().forEach(s => {
                const b = document.createElement("button");
                b.textContent = `-${s}`;
                b.addEventListener("click", () => adjustAngle(-s));
                neg.appendChild(b);
            });

            steps.forEach(s => {
                const b = document.createElement("button");
                b.textContent = `+${s}`;
                b.addEventListener("click", () => adjustAngle(+s));
                pos.appendChild(b);
            });

            renderHotkeyButtons();
        }

        function renderHotkeyButtons() {
            const host = document.getElementById("hotkeyButtons");
            host.innerHTML = "";
            hotkeys.forEach((v, idx) => {
                const b = document.createElement("button");
                b.className = "tiny";
                b.textContent = `${v}°`;
                b.title = `Hotkey ${idx + 1}: send ${v}°`;
                b.addEventListener("click", async () => {
                    if (!selectedLocation) {
                        alert("Select a servo first.");
                        return;
                    }
                    setAngleInput(v);
                    await sendAngle(v);
                });
                host.appendChild(b);
            });
        }

        /* -------------------- Hotkeys programmable inputs -------------------- */
        function syncHotkeyInputs() {
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById(`hk${i}`);
                el.value = String(hotkeys[i]);
            }
        }

        function attachHotkeyInputHandlers() {
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById(`hk${i}`);
                el.addEventListener("change", () => {
                    const v = clampInt(toInt(el.value, hotkeys[i]), 0, 270);
                    hotkeys[i] = v;
                    el.value = String(v);
                    saveHotkeys();
                    renderHotkeyButtons();
                });
            }
        }

        /* -------------------- Notes -------------------- */
        let notesSaveTimer = null;
        let notesLastSent = null;

        function setNotesStatus(text, cls = "muted") {
            const el = document.getElementById("notesStatus");
            el.className = cls;
            el.textContent = text;
        }

        async function loadNotes() {
            const resp = await api("/api/channel_notes");
            if (!resp.ok) {
                setNotesStatus("Notes: failed to load", "danger");
                return;
            }
            const notes = (resp.data && typeof resp.data.notes === "string") ? resp.data.notes : "";
            const area = document.getElementById("notesArea");
            area.value = notes;
            notesLastSent = notes;
            setNotesStatus("Notes: loaded", "muted");
        }

        function scheduleNotesSave() {
            if (notesSaveTimer) clearTimeout(notesSaveTimer);
            notesSaveTimer = setTimeout(async () => {
                const area = document.getElementById("notesArea");
                const notes = String(area.value ?? "");
                if (notes === notesLastSent) return;

                setNotesStatus("Notes: saving…", "muted");
                const resp = await api("/api/channel_notes", "POST", { notes });
                if (!resp.ok) {
                    setNotesStatus(`Notes: save failed (${resp.data?.error || resp.status})`, "danger");
                    return;
                }
                notesLastSent = notes;
                setNotesStatus("Notes: saved", "ok");
            }, 500);
        }

        /* -------------------- Init + refresh -------------------- */
        async function refresh() {
            const resp = await api("/api/config");
            if (!resp.ok) {
                alert("Failed to load config");
                return;
            }

            locations = resp.data.locations;
            draft = resp.data.draft;
            availableChannels = resp.data.available_channels;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);

            const hw = document.getElementById("hw-status");
            if (resp.data.hardware_available) {
                hw.innerHTML = `Hardware: <b>available</b>`;
            } else {
                const msg = resp.data.hardware_error ? ` (${resp.data.hardware_error})` : "";
                hw.innerHTML = `Hardware: <span class="danger"><b>unavailable</b></span>${msg}`;
            }

            renderControlBar();
            renderServoButtons();
            buildChannelSelectOptions();
            syncSelectedSidebar();
        }

        // Save / Reset
        document.getElementById("saveBtn").addEventListener("click", async () => {
            const resp = await api("/api/save", "POST", {});
            if (!resp.ok) {
                alert(resp.data.error || "Save failed");
                return;
            }
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
        });

        document.getElementById("resetBtn").addEventListener("click", async () => {
            const resp = await api("/api/reset", "POST", {});
            if (!resp.ok) {
                alert(resp.data.error || "Reset failed");
                return;
            }
            draft = resp.data.draft;
            availableChannels = resp.data.available_channels;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
            buildChannelSelectOptions();
            syncSelectedSidebar();
        });

        // Servo buttons
        for (const [btnId, locKey] of Object.entries(BUTTON_TO_LOCATION)) {
            const btn = document.getElementById(btnId);
            btn.addEventListener("click", () => applySelection(locKey));
        }

        // Channel dropdown (selected servo only)
        document.getElementById("channelSelect").addEventListener("change", async (e) => {
            if (!selectedLocation) return;
            const v = e.target.value;
            const ch = v === "" ? null : parseInt(v, 10);

            const resp = await api("/api/channel", "POST", { location: selectedLocation, channel: ch });
            if (!resp.ok) {
                alert(resp.data.error || "Failed to set channel");
                buildChannelSelectOptions(); // revert UI
                return;
            }
            draft = resp.data.draft;
            availableChannels = resp.data.available_channels;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
            buildChannelSelectOptions();
        });

        // Limits editing hooks
        document.getElementById("minDeg").addEventListener("change", pushLimits);
        document.getElementById("maxDeg").addEventListener("change", pushLimits);
        document.getElementById("invertChk").addEventListener("change", pushLimits);

        // Angle input UX: auto-select on focus/click
        const angleInput = document.getElementById("angleInput");
        angleInput.addEventListener("focus", () => angleInput.select());
        angleInput.addEventListener("click", () => angleInput.select());
        angleInput.addEventListener("keydown", async (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                document.getElementById("sendBtn").click();
            }
        });

        // Send button
        document.getElementById("sendBtn").addEventListener("click", async () => {
            if (!selectedLocation) {
                alert("Select a servo first.");
                return;
            }
            const parsed = getAngleFromInput();
            if (!parsed.ok) {
                alert(parsed.error);
                return;
            }
            const angle = parsed.value;
            setAngleInput(angle);
            await sendAngle(angle);
        });

        // Notes field: debounce save
        const notesArea = document.getElementById("notesArea");
        notesArea.addEventListener("input", scheduleNotesSave);

        // Init
        loadLastAngles();
        loadHotkeys();
        syncHotkeyInputs();
        attachHotkeyInputHandlers();
        setAngleInput(0);

        refresh();
        loadNotes();
    </script>
</body>

</html>