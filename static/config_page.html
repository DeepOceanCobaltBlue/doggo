<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Doggo Config</title>
    <style>
        :root {
            --bg: #0f1220;
            --panel: #181c2f;
            --accent: #4da3ff;
            --text: #e6e8f0;
            --muted: #9aa0b3;
            --selected: #263a5f;
            --danger: #ff5d5d;
            --ok: #4cff91;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
            background: var(--bg);
            color: var(--text);
        }

        .wrap {
            display: grid;
            grid-template-columns: 1fr 360px;
            grid-template-rows: 1fr 140px;
            height: 100vh;
            gap: 12px;
            padding: 12px;
        }

        .main {
            background: var(--panel);
            border-radius: 16px;
            position: relative;
            overflow: auto;
            min-width: 980px;
            min-height: 680px;
        }

        .sidebar {
            background: var(--panel);
            border-radius: 16px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            overflow: auto;
        }

        .bar {
            grid-column: 1 / span 2;
            background: var(--panel);
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            overflow: hidden;
        }

        .barRow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .muted {
            color: var(--muted);
            font-size: 13px;
        }

        .row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        button {
            background: transparent;
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 12px;
            padding: 10px 12px;
            cursor: pointer;
        }

        button.primary {
            border-color: var(--accent);
            color: var(--accent);
        }

        button:disabled {
            opacity: .35;
            cursor: not-allowed;
        }

        .danger {
            color: var(--danger);
        }

        .ok {
            color: var(--ok);
        }

        .robot-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.95;
            filter: saturate(0.9) contrast(1.05);
        }

        .widget {
            position: absolute;
            min-width: 220px;
            background: rgba(15, 18, 32, .84);
            border: 1px solid rgba(255, 255, 255, .14);
            border-radius: 14px;
            padding: 10px;
            transform: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
        }

        .widget.selected {
            outline: 2px solid var(--accent);
            background: rgba(38, 58, 95, .85);
        }

        .widget .label {
            font-weight: 600;
            margin-bottom: 8px;
        }

        select {
            width: 100%;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: #0f1220;
            color: var(--text);
        }

        .widget .btnrow {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .widget .btnrow button {
            flex: 1;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: #0f1220;
            color: var(--text);
        }

        input[type="checkbox"] {
            transform: scale(1.1);
        }

        textarea {
            width: 100%;
            min-height: 120px;
            resize: vertical;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: #0f1220;
            color: var(--text);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            line-height: 1.35;
        }

        .divider {
            height: 1px;
            background: rgba(255, 255, 255, .10);
            margin: 4px 0;
        }

        .steps {
            display: flex;
            gap: 8px;
        }

        .steps button {
            min-width: 64px;
        }

        .angleBox {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, .14);
            border-radius: 14px;
            background: #0f1220;
        }

        .angleBox input {
            width: 110px;
            text-align: center;
            font-size: 18px;
            font-weight: 800;
            padding: 10px 10px;
        }

        .hotkeys {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .hotkeys button {
            min-width: 70px;
        }

        .tiny {
            font-size: 12px;
            padding: 8px 10px;
            border-radius: 10px;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="main" id="robot-panel">
            <img class="robot-img"
                src="https://images.unsplash.com/photo-1529429611273-1f7b0fbe0a2b?auto=format&fit=crop&w=1400&q=80"
                alt="Robot" />
        </div>

        <div class="sidebar">
            <div>
                <div class="row">
                    <div>
                        <div style="font-size:18px;font-weight:800;">Doggo Config</div>
                        <div class="muted">Assign channels + set per-location limits.</div>
                    </div>
                </div>
                <div id="hw-status" class="muted" style="margin-top:8px;"></div>
            </div>

            <div class="divider"></div>

            <div class="row">
                <button id="saveBtn" class="primary" disabled>Save</button>
                <button id="resetBtn" disabled>Reset</button>
            </div>

            <div class="divider"></div>

            <div>
                <div style="font-weight:800; margin-bottom:8px;">Selected location</div>
                <div id="selectedLabel" class="muted">None</div>
            </div>

            <div class="field">
                <label class="muted">Min angle (deg)</label>
                <input id="minDeg" type="number" min="0" max="270" step="1" disabled />
            </div>

            <div class="field">
                <label class="muted">Max angle (deg)</label>
                <input id="maxDeg" type="number" min="0" max="270" step="1" disabled />
            </div>

            <div class="row">
                <label class="muted" for="invertChk">Invert</label>
                <input id="invertChk" type="checkbox" disabled />
            </div>

            <div class="divider"></div>

            <div>
                <div style="font-weight:800; margin-bottom:8px;">Hotkeys (programmable)</div>
                <div class="muted" style="margin-bottom:8px;">Edit values here; buttons are on the bottom bar.</div>
                <div class="field" style="gap:10px;">
                    <input id="hk0" type="number" min="0" max="270" step="1" />
                    <input id="hk1" type="number" min="0" max="270" step="1" />
                    <input id="hk2" type="number" min="0" max="270" step="1" />
                    <input id="hk3" type="number" min="0" max="270" step="1" />
                    <input id="hk4" type="number" min="0" max="270" step="1" />
                    <input id="hk5" type="number" min="0" max="270" step="1" />
                </div>
            </div>

            <div class="divider"></div>

            <div>
                <div style="font-weight:800; margin-bottom:8px;">Notes</div>
                <textarea id="notesArea"
                    placeholder="Saved to config/channel_notes.json (not part of config_file.json)."></textarea>
                <div id="notesStatus" class="muted" style="margin-top:6px;">—</div>
            </div>

            <div class="divider"></div>

            <div class="muted">
                Limits apply when you send commands in this app and will be saved to
                <code>config/config_file.json</code>.
            </div>
        </div>

        <div class="bar">
            <div class="barRow">
                <div class="steps" id="negSteps"></div>

                <div class="angleBox">
                    <input id="angleInput" type="text" inputmode="numeric" value="0" />
                    <button id="sendBtn" class="primary">Send</button>
                </div>

                <div class="steps" id="posSteps"></div>
            </div>

            <div class="barRow">
                <div class="hotkeys" id="hotkeyButtons"></div>
            </div>
        </div>
    </div>

    <script>
        /* -------------------- State -------------------- */
        let locations = [];
        let draft = null;                 // full draft config object
        let availableChannels = [];
        let selectedLocation = null;

        // Per-location last commanded angle (persisted)
        const LAST_ANGLES_KEY = "doggo:lastAngles:v1";
        let lastAngles = {};

        // Hotkeys (persisted)
        const HOTKEYS_KEY = "doggo:hotkeys:v1";
        let hotkeys = [0, 70, 135, 200, 250, 270];

        // Current working angle in the box
        let currentAngle = 0;

        const steps = [1, 5, 10];

        /* Widget layout (percent-based, tweak freely) */
        const widgetPositions = {
            front_left_hip: { x: 20, y: 70 },
            front_left_knee: { x: 20, y: 200 },

            front_right_hip: { x: 740, y: 70 },
            front_right_knee: { x: 740, y: 200 },

            back_left_hip: { x: 140, y: 360 },
            back_left_knee: { x: 140, y: 490 },

            back_right_hip: { x: 620, y: 360 },
            back_right_knee: { x: 620, y: 490 },
        };


        /* -------------------- API helpers -------------------- */
        async function api(url, method = "GET", body = null) {
            const opts = { method, headers: {} };
            if (body) {
                opts.headers["Content-Type"] = "application/json";
                opts.body = JSON.stringify(body);
            }
            const res = await fetch(url, opts);
            const data = await res.json();
            return { ok: res.ok, status: res.status, data };
        }

        /* -------------------- Persistence -------------------- */
        function loadLastAngles() {
            try {
                const s = localStorage.getItem(LAST_ANGLES_KEY);
                lastAngles = s ? JSON.parse(s) : {};
                if (typeof lastAngles !== "object" || lastAngles === null) lastAngles = {};
            } catch {
                lastAngles = {};
            }
        }

        function saveLastAngles() {
            try {
                localStorage.setItem(LAST_ANGLES_KEY, JSON.stringify(lastAngles));
            } catch { }
        }

        function loadHotkeys() {
            try {
                const s = localStorage.getItem(HOTKEYS_KEY);
                const arr = s ? JSON.parse(s) : null;
                if (Array.isArray(arr) && arr.length === 6) {
                    hotkeys = arr.map(v => clampInt(toInt(v, 0), 0, 270));
                }
            } catch { }
        }

        function saveHotkeys() {
            try {
                localStorage.setItem(HOTKEYS_KEY, JSON.stringify(hotkeys));
            } catch { }
        }

        /* -------------------- Small utils -------------------- */
        function clampInt(v, lo, hi) {
            return Math.max(lo, Math.min(hi, v));
        }

        function toInt(v, fallback = null) {
            const n = Number.parseInt(String(v).trim(), 10);
            return Number.isFinite(n) ? n : fallback;
        }

        function isStrictIntegerString(s) {
            // Only digits, no signs, no spaces, no decimals
            return /^[0-9]+$/.test(s);
        }

        function setAngleInput(v) {
            const el = document.getElementById("angleInput");
            el.value = String(v);
            currentAngle = v;
        }

        function getAngleFromInput() {
            const el = document.getElementById("angleInput");
            const raw = String(el.value ?? "").trim();
            if (!isStrictIntegerString(raw)) {
                return { ok: false, error: "Angle must be digits only (0..270)." };
            }
            const n = toInt(raw, null);
            if (n === null) return { ok: false, error: "Angle must be an integer." };
            if (n < 0 || n > 270) return { ok: false, error: "Angle out of range (0..270)." };
            return { ok: true, value: n };
        }

        /* -------------------- Render -------------------- */
        function renderWidgets() {
            const panel = document.getElementById("robot-panel");
            panel.querySelectorAll(".widget").forEach(w => w.remove());

            locations.forEach(loc => {
                const pos = widgetPositions[loc.key] || { x: 50, y: 50 };

                const w = document.createElement("div");
                w.className = "widget" + (selectedLocation === loc.key ? " selected" : "");
                w.style.left = `${pos.x}px`;
                w.style.top = `${pos.y}px`;

                const label = document.createElement("div");
                label.className = "label";
                label.textContent = loc.label;
                w.appendChild(label);

                const sel = document.createElement("select");
                sel.dataset.loc = loc.key;

                const optNone = document.createElement("option");
                optNone.value = "";
                optNone.textContent = "— Unassigned —";
                sel.appendChild(optNone);

                const current = draft.locations[loc.key].channel;
                const pool = [...availableChannels];
                if (current !== null && current !== undefined && !pool.includes(current)) pool.push(current);
                pool.sort((a, b) => a - b);

                pool.forEach(ch => {
                    const o = document.createElement("option");
                    o.value = String(ch);
                    o.textContent = `Channel ${ch}`;
                    sel.appendChild(o);
                });

                sel.value = (current === null || current === undefined) ? "" : String(current);

                sel.addEventListener("change", async (e) => {
                    const v = e.target.value;
                    const ch = v === "" ? null : parseInt(v, 10);
                    const resp = await api("/api/channel", "POST", { location: loc.key, channel: ch });
                    if (!resp.ok) {
                        alert(resp.data.error || "Failed to set channel");
                    } else {
                        draft = resp.data.draft;
                        availableChannels = resp.data.available_channels;
                        setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
                        renderWidgets();
                    }
                });

                w.appendChild(sel);

                const btnRow = document.createElement("div");
                btnRow.className = "btnrow";

                const selectBtn = document.createElement("button");
                selectBtn.textContent = "Select";
                selectBtn.className = "primary";
                selectBtn.addEventListener("click", () => {
                    selectedLocation = loc.key;
                    syncSelectedSidebar();
                    // Load per-location last angle if present
                    if (lastAngles[selectedLocation] !== undefined) {
                        const v = clampInt(toInt(lastAngles[selectedLocation], 0), 0, 270);
                        setAngleInput(v);
                    }
                    renderWidgets();
                });

                btnRow.appendChild(selectBtn);
                w.appendChild(btnRow);

                panel.appendChild(w);
            });
        }

        function setSaveResetEnabled(saveEnabled, resetEnabled) {
            document.getElementById("saveBtn").disabled = !saveEnabled;
            document.getElementById("resetBtn").disabled = !resetEnabled;
        }

        function renderControlBar() {
            const neg = document.getElementById("negSteps");
            const pos = document.getElementById("posSteps");
            neg.innerHTML = "";
            pos.innerHTML = "";

            steps.slice().reverse().forEach(s => {
                const b = document.createElement("button");
                b.textContent = `-${s}`;
                b.addEventListener("click", () => adjustAngle(-s));
                neg.appendChild(b);
            });

            steps.forEach(s => {
                const b = document.createElement("button");
                b.textContent = `+${s}`;
                b.addEventListener("click", () => adjustAngle(+s));
                pos.appendChild(b);
            });

            renderHotkeyButtons();
        }

        function renderHotkeyButtons() {
            const host = document.getElementById("hotkeyButtons");
            host.innerHTML = "";
            hotkeys.forEach((v, idx) => {
                const b = document.createElement("button");
                b.className = "tiny";
                b.textContent = `${v}°`;
                b.title = `Hotkey ${idx + 1}: send ${v}°`;
                b.addEventListener("click", async () => {
                    if (!selectedLocation) {
                        alert("Select a location first.");
                        return;
                    }
                    setAngleInput(v);
                    await sendAngle(v);
                });
                host.appendChild(b);
            });
        }

        async function adjustAngle(delta) {
            if (!selectedLocation) {
                alert("Select a location first.");
                return;
            }
            const next = clampInt(currentAngle + delta, 0, 270);
            setAngleInput(next);
            await sendAngle(next);
        }

        async function sendAngle(angle) {
            if (!selectedLocation) {
                alert("Select a location first.");
                return;
            }
            const resp = await api("/api/command", "POST", { location: selectedLocation, angle_deg: angle });
            if (!resp.ok) {
                alert(resp.data.error || "Command failed");
                return;
            }
            // Save per-location last commanded angle
            lastAngles[selectedLocation] = angle;
            saveLastAngles();
        }

        function syncSelectedSidebar() {
            const labelEl = document.getElementById("selectedLabel");
            const minEl = document.getElementById("minDeg");
            const maxEl = document.getElementById("maxDeg");
            const invEl = document.getElementById("invertChk");

            if (!selectedLocation) {
                labelEl.textContent = "None";
                minEl.value = "";
                maxEl.value = "";
                invEl.checked = false;
                minEl.disabled = true;
                maxEl.disabled = true;
                invEl.disabled = true;
                return;
            }

            const loc = locations.find(l => l.key === selectedLocation);
            labelEl.textContent = loc ? loc.label : selectedLocation;

            const lim = draft.locations[selectedLocation].limits;
            minEl.value = String(lim.deg_min);
            maxEl.value = String(lim.deg_max);
            invEl.checked = !!lim.invert;

            minEl.disabled = false;
            maxEl.disabled = false;
            invEl.disabled = false;
        }

        async function pushLimits() {
            if (!selectedLocation) return;

            const minEl = document.getElementById("minDeg");
            const maxEl = document.getElementById("maxDeg");
            const invEl = document.getElementById("invertChk");

            const deg_min = parseInt(minEl.value, 10);
            const deg_max = parseInt(maxEl.value, 10);
            const invert = !!invEl.checked;

            const resp = await api("/api/limits", "POST", { location: selectedLocation, deg_min, deg_max, invert });
            if (!resp.ok) {
                alert(resp.data.error || "Failed to set limits");
                return;
            }
            draft = resp.data.draft;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
            syncSelectedSidebar();
        }

        /* -------------------- Notes -------------------- */
        let notesSaveTimer = null;
        let notesLastSent = null;

        function setNotesStatus(text, cls = "muted") {
            const el = document.getElementById("notesStatus");
            el.className = cls;
            el.textContent = text;
        }

        async function loadNotes() {
            const resp = await api("/api/channel_notes");
            if (!resp.ok) {
                setNotesStatus("Notes: failed to load", "danger");
                return;
            }
            const notes = (resp.data && typeof resp.data.notes === "string") ? resp.data.notes : "";
            const area = document.getElementById("notesArea");
            area.value = notes;
            notesLastSent = notes;
            setNotesStatus("Notes: loaded", "muted");
        }

        function scheduleNotesSave() {
            if (notesSaveTimer) clearTimeout(notesSaveTimer);
            notesSaveTimer = setTimeout(async () => {
                const area = document.getElementById("notesArea");
                const notes = String(area.value ?? "");
                if (notes === notesLastSent) return;

                setNotesStatus("Notes: saving…", "muted");
                const resp = await api("/api/channel_notes", "POST", { notes });
                if (!resp.ok) {
                    setNotesStatus(`Notes: save failed (${resp.data?.error || resp.status})`, "danger");
                    return;
                }
                notesLastSent = notes;
                setNotesStatus("Notes: saved", "ok");
            }, 500);
        }

        /* -------------------- Hotkey config UI -------------------- */
        function syncHotkeyInputs() {
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById(`hk${i}`);
                el.value = String(hotkeys[i]);
            }
        }

        function attachHotkeyInputHandlers() {
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById(`hk${i}`);
                el.addEventListener("change", () => {
                    const v = clampInt(toInt(el.value, hotkeys[i]), 0, 270);
                    hotkeys[i] = v;
                    el.value = String(v);
                    saveHotkeys();
                    renderHotkeyButtons();
                });
            }
        }

        /* -------------------- Actions -------------------- */
        async function refresh() {
            const resp = await api("/api/config");
            if (!resp.ok) {
                alert("Failed to load config");
                return;
            }
            locations = resp.data.locations;
            draft = resp.data.draft;
            availableChannels = resp.data.available_channels;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);

            // Hardware status
            const hw = document.getElementById("hw-status");
            if (resp.data.hardware_available) {
                hw.innerHTML = `Hardware: <b>available</b>`;
            } else {
                const msg = resp.data.hardware_error ? ` (${resp.data.hardware_error})` : "";
                hw.innerHTML = `Hardware: <span class="danger"><b>unavailable</b></span>${msg}`;
            }

            renderWidgets();
            renderControlBar();
            syncSelectedSidebar();
        }

        document.getElementById("saveBtn").addEventListener("click", async () => {
            const resp = await api("/api/save", "POST", {});
            if (!resp.ok) {
                alert(resp.data.error || "Save failed");
                return;
            }
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
        });

        document.getElementById("resetBtn").addEventListener("click", async () => {
            const resp = await api("/api/reset", "POST", {});
            if (!resp.ok) {
                alert(resp.data.error || "Reset failed");
                return;
            }
            draft = resp.data.draft;
            availableChannels = resp.data.available_channels;
            setSaveResetEnabled(resp.data.save_enabled, resp.data.reset_enabled);
            renderWidgets();
            syncSelectedSidebar();
        });

        // Limits editing hooks
        document.getElementById("minDeg").addEventListener("change", pushLimits);
        document.getElementById("maxDeg").addEventListener("change", pushLimits);
        document.getElementById("invertChk").addEventListener("change", pushLimits);

        // Angle input: auto-highlight/select on focus/click
        const angleInput = document.getElementById("angleInput");
        angleInput.addEventListener("focus", () => angleInput.select());
        angleInput.addEventListener("click", () => angleInput.select());

        // Enter key sends
        angleInput.addEventListener("keydown", async (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                document.getElementById("sendBtn").click();
            }
        });

        // Send button
        document.getElementById("sendBtn").addEventListener("click", async () => {
            if (!selectedLocation) {
                alert("Select a location first.");
                return;
            }
            const parsed = getAngleFromInput();
            if (!parsed.ok) {
                alert(parsed.error);
                return;
            }
            const angle = parsed.value;
            setAngleInput(angle);
            await sendAngle(angle);
        });

        // Notes field: debounce save
        const notesArea = document.getElementById("notesArea");
        notesArea.addEventListener("input", scheduleNotesSave);

        // Init
        loadLastAngles();
        loadHotkeys();
        syncHotkeyInputs();
        attachHotkeyInputHandlers();
        setAngleInput(0);

        refresh();
        loadNotes();
    </script>
</body>

</html>